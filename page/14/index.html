<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"shakudada.xyz","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"79C1GXGOC6","apiKey":"225fa4bf2bc37c3e46a671682674fe37","indexName":"my-hexo-blog","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="dinosaur">
<meta property="og:url" content="https://shakudada.xyz/page/14/index.html">
<meta property="og:site_name" content="dinosaur">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="dinosaur">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://shakudada.xyz/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>dinosaur</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dinosaur</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shakudada.xyz/2022/02/18/jdk-%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dinosaur">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dinosaur">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/18/jdk-%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">jdk 编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-18 13:05:13" itemprop="dateCreated datePublished" datetime="2022-02-18T13:05:13+08:00">2022-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 11:42:47" itemprop="dateModified" datetime="2023-10-25T11:42:47+08:00">2023-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>jdk 某个版本之后是自举的，所以编译jdk之前先有一个jdk。<br>主要参照<a target="_blank" rel="noopener" href="https://openjdk.java.net/groups/build/doc/building.html">https://openjdk.java.net/groups/build/doc/building.html</a></p>
<h5 id="下载jdk"><a href="#下载jdk" class="headerlink" title="下载jdk"></a>下载jdk</h5><h5 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h5><p>src\hotspot\share\interpreter\bytecodes.cpp</p>
<p>BytecodeInterpreter::run</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  TemplateTable::if_icmp (cc=4294967295) at /home/ubuntu/jdk/src/hotspot/cpu/x86/templateTable_x86.cpp:2381</span><br><span class="line">#1  0x00007ffff70a9519 in Template::generate (this=0x7ffff7d60be0 &lt;TemplateTable::_template_table+5088&gt;, masm=0x7ffff0019760) at /home/ubuntu/jdk/src/hotspot/share/interpreter/templateTable.cpp:63</span><br><span class="line">#2  0x00007ffff709bde8 in TemplateInterpreterGenerator::generate_and_dispatch (this=0x7ffff5c5da40, t=0x7ffff7d60be0 &lt;TemplateTable::_template_table+5088&gt;, tos_out=vtos)</span><br><span class="line">    at /home/ubuntu/jdk/src/hotspot/share/interpreter/templateInterpreterGenerator.cpp:392</span><br><span class="line">#3  0x00007ffff709b934 in TemplateInterpreterGenerator::set_short_entry_points (this=0x7ffff5c5da40, t=0x7ffff7d60be0 &lt;TemplateTable::_template_table+5088&gt;, </span><br><span class="line">    bep=@0x7ffff5c5d398: 0x7fffe1008a37 &quot;H\211d$\330H\201&quot;, &lt;incomplete sequence \354\200&gt;, cep=@0x7ffff5c5d3a0: 0x7fffe1008a37 &quot;H\211d$\330H\201&quot;, &lt;incomplete sequence \354\200&gt;, </span><br><span class="line">    sep=@0x7ffff5c5d3a8: 0x7fffe1008a37 &quot;H\211d$\330H\201&quot;, &lt;incomplete sequence \354\200&gt;, aep=@0x7ffff5c5d3b0: 0x7fffe1008a37 &quot;H\211d$\330H\201&quot;, &lt;incomplete sequence \354\200&gt;, </span><br><span class="line">    iep=@0x7ffff5c5d3b8: 0x7fffe1028807 &quot;PSQRH\213M\330H\205\311\017\204&quot;, &lt;incomplete sequence \312&gt;, lep=@0x7ffff5c5d3c0: 0x7fffe1008a37 &quot;H\211d$\330H\201&quot;, &lt;incomplete sequence \354\200&gt;, </span><br><span class="line">    fep=@0x7ffff5c5d3c8: 0x7fffe1008a37 &quot;H\211d$\330H\201&quot;, &lt;incomplete sequence \354\200&gt;, dep=@0x7ffff5c5d3d0: 0x7fffe1008a37 &quot;H\211d$\330H\201&quot;, &lt;incomplete sequence \354\200&gt;, </span><br><span class="line">    vep=@0x7ffff5c5d3d8: 0x7fffe1028800 &quot;\213\004$H\203\304\bPSQRH\213M\330H\205\311\017\204&quot;, &lt;incomplete sequence \312&gt;) at /home/ubuntu/jdk/src/hotspot/share/interpreter/templateInterpreterGenerator.cpp:356</span><br><span class="line">#4  0x00007ffff709b46c in TemplateInterpreterGenerator::set_entry_points (this=0x7ffff5c5da40, code=Bytecodes::_if_icmpeq) at /home/ubuntu/jdk/src/hotspot/share/interpreter/templateInterpreterGenerator.cpp:325</span><br><span class="line">#5  0x00007ffff709b06d in TemplateInterpreterGenerator::set_entry_points_for_all_bytes (this=0x7ffff5c5da40) at /home/ubuntu/jdk/src/hotspot/share/interpreter/templateInterpreterGenerator.cpp:281</span><br><span class="line">#6  0x00007ffff709ac13 in TemplateInterpreterGenerator::generate_all (this=0x7ffff5c5da40) at /home/ubuntu/jdk/src/hotspot/share/interpreter/templateInterpreterGenerator.cpp:234</span><br><span class="line">#7  0x00007ffff70993cb in TemplateInterpreterGenerator::TemplateInterpreterGenerator (this=0x7ffff5c5da40, _code=0x7ffff00a28b0) at /home/ubuntu/jdk/src/hotspot/share/interpreter/templateInterpreterGenerator.cpp:42</span><br><span class="line">#8  0x00007ffff7097e5b in TemplateInterpreter::initialize () at /home/ubuntu/jdk/src/hotspot/share/interpreter/templateInterpreter.cpp:56</span><br><span class="line">#9  0x00007ffff69e06a2 in interpreter_init () at /home/ubuntu/jdk/src/hotspot/share/interpreter/interpreter.cpp:116</span><br><span class="line">#10 0x00007ffff69bbe73 in init_globals () at /home/ubuntu/jdk/src/hotspot/share/runtime/init.cpp:119</span><br><span class="line">#11 0x00007ffff70d59b7 in Threads::create_vm (args=0x7ffff5c5de20, canTryAgain=0x7ffff5c5dd2b) at /home/ubuntu/jdk/src/hotspot/share/runtime/thread.cpp:3728</span><br><span class="line">#12 0x00007ffff6adcd5d in JNI_CreateJavaVM_inner (vm=0x7ffff5c5de78, penv=0x7ffff5c5de80, args=0x7ffff5c5de20) at /home/ubuntu/jdk/src/hotspot/share/prims/jni.cpp:3945</span><br><span class="line">#13 0x00007ffff6add0b1 in JNI_CreateJavaVM (vm=0x7ffff5c5de78, penv=0x7ffff5c5de80, args=0x7ffff5c5de20) at /home/ubuntu/jdk/src/hotspot/share/prims/jni.cpp:4036</span><br><span class="line">#14 0x00007ffff7fba88c in InitializeJVM (pvm=0x7ffff5c5de78, penv=0x7ffff5c5de80, ifn=0x7ffff5c5ded0) at /home/ubuntu/jdk/src/java.base/share/native/libjli/java.c:1527</span><br><span class="line">#15 0x00007ffff7fb7447 in JavaMain (_args=0x7fffffffb040) at /home/ubuntu/jdk/src/java.base/share/native/libjli/java.c:414</span><br><span class="line">#16 0x00007ffff7d7a609 in start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:477</span><br><span class="line">#17 0x00007ffff7ed8293 in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span><br></pre></td></tr></table></figure>

<h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Thread 2 &quot;java&quot; hit Breakpoint 3, SystemDictionary::load_instance_class (class_name=0x7fffcc2d90f0, class_loader=..., __the_thread__=0x7ffff001b800)</span><br><span class="line">    at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/classfile/systemDictionary.cpp:1386</span><br><span class="line">1386	InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) &#123;</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  SystemDictionary::load_instance_class (class_name=0x7fffcc2d90f0, class_loader=..., __the_thread__=0x7ffff001b800)</span><br><span class="line">    at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/classfile/systemDictionary.cpp:1386</span><br><span class="line">#1  0x00007ffff61bf8ab in SystemDictionary::resolve_instance_class_or_null (name=0x7fffcc2d90f0, class_loader=..., protection_domain=..., __the_thread__=0x7ffff001b800)</span><br><span class="line">    at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/classfile/systemDictionary.cpp:854</span><br><span class="line">#2  0x00007ffff61bdcf8 in SystemDictionary::resolve_instance_class_or_null_helper (class_name=0x7fffcc2d90f0, class_loader=..., protection_domain=..., __the_thread__=0x7ffff001b800)</span><br><span class="line">    at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/classfile/systemDictionary.cpp:272</span><br><span class="line">#3  0x00007ffff61bdb5e in SystemDictionary::resolve_or_null (class_name=0x7fffcc2d90f0, class_loader=..., protection_domain=..., __the_thread__=0x7ffff001b800)</span><br><span class="line">    at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/classfile/systemDictionary.cpp:255</span><br><span class="line">#4  0x00007ffff61bd7d1 in SystemDictionary::resolve_or_fail (class_name=0x7fffcc2d90f0, class_loader=..., protection_domain=..., throw_error=true, __the_thread__=0x7ffff001b800)</span><br><span class="line">    at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/classfile/systemDictionary.cpp:203</span><br><span class="line">#5  0x00007ffff61bdae8 in SystemDictionary::resolve_or_fail (class_name=0x7fffcc2d90f0, throw_error=true, __the_thread__=0x7ffff001b800)</span><br><span class="line">    at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/classfile/systemDictionary.cpp:245</span><br><span class="line">#6  0x00007ffff61c3490 in SystemDictionary::resolve_wk_klass (id=SystemDictionary::Object_klass_knum, __the_thread__=0x7ffff001b800)</span><br><span class="line">    at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/classfile/systemDictionary.cpp:1938</span><br><span class="line">#7  0x00007ffff61c35c5 in SystemDictionary::resolve_wk_klasses_until (limit_id=SystemDictionary::Cloneable_klass_knum, start_id=@0x7ffff7fbc974: SystemDictionary::Object_klass_knum, </span><br><span class="line">    __the_thread__=0x7ffff001b800) at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/classfile/systemDictionary.cpp:1948</span><br><span class="line">#8  0x00007ffff5c5c46d in SystemDictionary::resolve_wk_klasses_through (end_id=SystemDictionary::Class_klass_knum, start_id=@0x7ffff7fbc974: SystemDictionary::Object_klass_knum, </span><br><span class="line">    __the_thread__=0x7ffff001b800) at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/classfile/systemDictionary.hpp:391</span><br><span class="line">#9  0x00007ffff61c37a3 in SystemDictionary::resolve_well_known_classes (__the_thread__=0x7ffff001b800) at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/classfile/systemDictionary.cpp:1991</span><br><span class="line">#10 0x00007ffff61c32d8 in SystemDictionary::initialize (__the_thread__=0x7ffff001b800) at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/classfile/systemDictionary.cpp:1898</span><br><span class="line">#11 0x00007ffff623b65c in Universe::genesis (__the_thread__=0x7ffff001b800) at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/memory/universe.cpp:329</span><br><span class="line">#12 0x00007ffff623dd21 in universe2_init () at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/memory/universe.cpp:953</span><br><span class="line">#13 0x00007ffff5a575e7 in init_globals () at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/runtime/init.cpp:125</span><br><span class="line">#14 0x00007ffff620ecbe in Threads::create_vm (args=0x7ffff7fbce20, canTryAgain=0x7ffff7fbcd2b) at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/runtime/thread.cpp:3731</span><br><span class="line">#15 0x00007ffff5b6b598 in JNI_CreateJavaVM_inner (vm=0x7ffff7fbce78, penv=0x7ffff7fbce80, args=0x7ffff7fbce20) at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/prims/jni.cpp:3935</span><br><span class="line">#16 0x00007ffff5b6b8c2 in JNI_CreateJavaVM (vm=0x7ffff7fbce78, penv=0x7ffff7fbce80, args=0x7ffff7fbce20) at /home/dinosaur/jdk12/jdk-jdk-12-25/src/hotspot/share/prims/jni.cpp:4021</span><br><span class="line">#17 0x00007ffff7bc6601 in InitializeJVM (pvm=0x7ffff7fbce78, penv=0x7ffff7fbce80, ifn=0x7ffff7fbced0) at /home/dinosaur/jdk12/jdk-jdk-12-25/src/java.base/share/native/libjli/java.c:1529</span><br><span class="line">#18 0x00007ffff7bc320c in JavaMain (_args=0x7fffffffaa30) at /home/dinosaur/jdk12/jdk-jdk-12-25/src/java.base/share/native/libjli/java.c:414</span><br><span class="line">#19 0x00007ffff71956db in start_thread (arg=0x7ffff7fbd700) at pthread_create.c:463</span><br><span class="line">#20 0x00007ffff78ef61f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(gdb) p class_name-&gt;_body@10</span><br><span class="line">$14 = &#123;&quot;ja&quot;, &quot;va&quot;, &quot;/l&quot;, &quot;an&quot;, &quot;g/&quot;, &quot;Ob&quot;, &quot;je&quot;, &quot;ct&quot;, &quot;\361&quot;, &lt;incomplete sequence \361&gt;, &quot;\377\377&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="解析文件流"><a href="#解析文件流" class="headerlink" title="解析文件流"></a>解析文件流</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassFileParser::parse_stream</span><br></pre></td></tr></table></figure>

<h3 id="find-transitive-override"><a href="#find-transitive-override" class="headerlink" title="find_transitive_override"></a>find_transitive_override</h3><p>重载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find_transitive_override</span><br><span class="line">update_inherited_vtable</span><br></pre></td></tr></table></figure>


<h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method::name_and_sig_as_C_string</span><br></pre></td></tr></table></figure>

<h4 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h4><ul>
<li><a target="_blank" rel="noopener" href="http://www.cs.ecu.edu/karl/5220/spr16/Notes/Bottom-up/lr0item.html">http://www.cs.ecu.edu/karl/5220/spr16/Notes/Bottom-up/lr0item.html</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shakudada.xyz/2022/01/04/croaring-bitmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dinosaur">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dinosaur">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/croaring-bitmap/" class="post-title-link" itemprop="url">croaring bitmap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 23:07:31" itemprop="dateCreated datePublished" datetime="2022-01-04T23:07:31+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 11:42:47" itemprop="dateModified" datetime="2023-10-25T11:42:47+08:00">2023-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/RoaringBitmap/CRoaring.git</span><br><span class="line">cd CRoaring/</span><br><span class="line">cd build/</span><br><span class="line">cmake  -DCMAKE_BUILD_TYPE=Debug .. </span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure>
<p>然后就可以了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shakudada.xyz/2021/12/30/roaring-bitmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dinosaur">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dinosaur">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/30/roaring-bitmap/" class="post-title-link" itemprop="url">roaring bitmap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-30 13:10:58" itemprop="dateCreated datePublished" datetime="2021-12-30T13:10:58+08:00">2021-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 11:42:47" itemprop="dateModified" datetime="2023-10-25T11:42:47+08:00">2023-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>bitmap 在某个长度之后会占用内存比array小,利用这个特性,可以将数据的存储压缩成bitmap存储.</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当我们有多个数字的数组,我们可以用多种方式描述一个数字.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array = [1 , 2 , 3 ,5,7]     (1)</span><br></pre></td></tr></table></figure>
<h3 id="方案1-直接使用数组"><a href="#方案1-直接使用数组" class="headerlink" title="方案1 , 直接使用数组"></a>方案1 , 直接使用数组</h3><p>假设每个数字是一个Uint32 ,也就是4字节的数字.</p>
<p>那么上面例子<code>(1)</code> 中占用的字节数:5*4 &#x3D; 20 字节 , 如果我们要存越大的数据需要的内存越多.我们占用的内存是线性的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory = array.size() * 4</span><br></pre></td></tr></table></figure>
<p>优点: </p>
<ul>
<li>有多少内存就可以存多少数据<br>缺点:</li>
<li>占用内存是线性的</li>
</ul>
<h3 id="方案2-直接使用4个字节的的位图"><a href="#方案2-直接使用4个字节的的位图" class="headerlink" title="方案2 , 直接使用4个字节的的位图"></a>方案2 , 直接使用4个字节的的位图</h3><p><img src="https://cdn4.shakudada.xyz/bitmap.png" alt="bitmap"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint32 num = 0 ; </span><br><span class="line">num |= num &lt;&lt; 1  ;</span><br><span class="line">num |= num &lt;&lt; 2   ;</span><br><span class="line">num |= num &lt;&lt; 3  ;</span><br><span class="line">num |= num &lt;&lt; 5 ;</span><br><span class="line">num |= num &lt;&lt; 7 ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么可以存多少个数字呢?<br><code>4*8 = 32</code> 也就是可以存32个数字</p>
<p>优点: </p>
<ul>
<li>占用内存是O(1) , 存储数量不随着数据变大而变大</li>
</ul>
<p>缺点</p>
<ul>
<li>用4个字节的位图最多可以描述一个32个<code>Uint</code>的数字</li>
</ul>
<h2 id="roaring-bitmap"><a href="#roaring-bitmap" class="headerlink" title="roaring bitmap"></a>roaring bitmap</h2><p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1709.07821.pdf">roaring bitmap</a></p>
<h3 id="更进一步-我们要存2-32个数"><a href="#更进一步-我们要存2-32个数" class="headerlink" title="更进一步,我们要存2^32个数"></a>更进一步,我们要存<code>2^32</code>个数</h3><ul>
<li><p>只使用bitmap<br>如果要用bitmap来存,我们要用 <code>2^32 / 8 = 2^29 byte =  256m</code> </p>
</li>
<li><p>只使用array<br>需要的内存：  <code>4*array.length byte</code></p>
</li>
</ul>
<p>bitmap和array的区别： bitmap会固定占用的内存，array则是动态占用内存。<br>上面的例子（存储4字节长度的数字数组），bitmap会固定占用256m，而array则动态长度。在数组比较小的时候，使用array比较好，在数组长度比较大的时候，则使用bitmap比较好。</p>
<p>核心公式： <code>number_length * n * 8 = 2^n</code><br>这里解释一下公式长度： <code>number_length</code> 描述的是一个数字的字节长度，比如要存储的是uint32 , 则<code>number_length = 4</code> , 如果要存储<code>uint64</code> ,则<code>number_length</code> &#x3D; 8 </p>
<p> <code>4 *n*8  = 2^n</code>  的解是16</p>
<p>所以用16个字节来描述一个联合体：<code>&#123;bitmap , array&#125;</code> , 当数组数量小于16的时候使用<code>array</code> 存储，当数量大于等于16的时候使用bitmap描述</p>
<h2 id="roaring-bitmap-容器的运算"><a href="#roaring-bitmap-容器的运算" class="headerlink" title="roaring bitmap 容器的运算"></a>roaring bitmap 容器的运算</h2><p>参考相关代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRoaring/include/roaring/containers/containers.h</span><br></pre></td></tr></table></figure>

<p>相关阅读:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1402.6407#:~:text=On%20synthetic%20and%20real%20data,based%20bitmap%20compression%20is%20best">https://arxiv.org/abs/1402.6407#:~:text=On%20synthetic%20and%20real%20data,based%20bitmap%20compression%20is%20best</a>.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shakudada.xyz/2021/11/30/%E7%A7%9F%E7%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dinosaur">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dinosaur">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/30/%E7%A7%9F%E7%BA%A6/" class="post-title-link" itemprop="url">租约</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-30 12:56:25" itemprop="dateCreated datePublished" datetime="2021-11-30T12:56:25+08:00">2021-11-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 11:42:47" itemprop="dateModified" datetime="2023-10-25T11:42:47+08:00">2023-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>A lease is a contract that gives its holder specified rights<br>over property for a limited period of time. In the context<br>of caching, a lease grants to its holder control over writes<br>to the covered datum during the term of the lease, such that<br>the server must obtain the approval of the leaseholder before the datum may be written. When a leaseholder grants<br>approval for a write, it invalidates its local copy of the da<br>租约是一个租约持有人在一定时间内有特别的权限的合约.<br>在缓存这个场景下,租约保证他的持有人在租约期限内有写的权限 , 所以当服务器</p>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ul>
<li>Leases: An Efficient Fault-Tolerant Mechanism for Distributed File Cache Consistency</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shakudada.xyz/2021/11/09/rabbit%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dinosaur">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dinosaur">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/09/rabbit%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">rabbit流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-09 12:50:04" itemprop="dateCreated datePublished" datetime="2021-11-09T12:50:04+08:00">2021-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 11:42:47" itemprop="dateModified" datetime="2023-10-25T11:42:47+08:00">2023-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server/deps/rabbit/src/rabbit_msg_store.erl</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">%% Message store is responsible for storing messages</span><br><span class="line">%% on disk and loading them back. The store handles both</span><br><span class="line">%% persistent messages and transient ones (when a node</span><br><span class="line">%% is under RAM pressure and needs to page messages out</span><br><span class="line">%% to disk). The store is responsible for locating messages</span><br><span class="line">%% on disk and maintaining an index.</span><br><span class="line">消息存储是响应式地存储在硬盘或者把他们从硬盘加载到内存.存储的例程回调包括持久化的消息和非持久化的消息(当使用内存高出一定阈值,会把消息调入到硬盘).</span><br><span class="line">这个存储模块会返回消息在硬盘的偏移,以及维持这个消息到硬盘的映射的索引.</span><br><span class="line"></span><br><span class="line">%% There are two message stores per node: one for transient</span><br><span class="line">%% and one for persistent messages.</span><br><span class="line">每个节点有两种消息: </span><br><span class="line">一个是对易失的消息 , 一个是持久化的消息</span><br><span class="line">%%</span><br><span class="line">%% Queue processes interact with the stores via clients.</span><br><span class="line"> 队列进程和存储模块通过客户端交互</span><br><span class="line">%% The components:</span><br><span class="line">%%</span><br><span class="line">%% Index: this is a mapping from MsgId to #msg_location&#123;&#125;.</span><br><span class="line">%%        By default, it&#x27;s in ETS, but other implementations can</span><br><span class="line">%%        be used.</span><br><span class="line">%% FileSummary: this maps File to #file_summary&#123;&#125; and is stored</span><br><span class="line">%%              in ETS.</span><br><span class="line">包括两个组件:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%% The basic idea is that messages are appended to the current file up</span><br><span class="line">%% until that file becomes too big (&gt; file_size_limit). At that point,</span><br><span class="line">%% the file is closed and a new file is created on the _right_ of the</span><br><span class="line">%% old file which is used for new messages. Files are named</span><br><span class="line">%% numerically ascending, thus the file with the lowest name is the</span><br><span class="line">%% eldest file.</span><br><span class="line">基本的思路是将消息加入到文件里面，直到文件变得足够大。在这个时候，会将文件关闭，</span><br><span class="line">然后创建一个新的文件添加到旧有文件的右边。文件名会升序命名，因此文件名数字比较</span><br><span class="line">小的就是比较旧的文件。</span><br><span class="line">%% We need to keep track of which messages are in which files (this is</span><br><span class="line">%% the index); how much useful data is in each file and which files</span><br><span class="line">%% are on the left and right of each other. This is the purpose of the</span><br><span class="line">%% file summary ETS table.</span><br><span class="line">我们需要确定消息在哪个文件（这就是一个索引的功能）; 还有多少数据是有效在每个文</span><br><span class="line">件以及每个文件的排序.这个的目的是为了确定表的统计.</span><br><span class="line">%% As messages are removed from files, holes appear in these</span><br><span class="line">%% files. The field ValidTotalSize contains the total amount of useful</span><br><span class="line">%% data left in the file. This is needed for garbage collection.</span><br><span class="line">当消息被从文件中移除,文件会出现空洞.ValidTotalSize字段会比有用的数据小,这需</span><br><span class="line">要垃圾回收.</span><br><span class="line">%% When we discover that a file is now empty, we delete it. When we</span><br><span class="line">%% discover that it can be combined with the useful data in either its</span><br><span class="line">%% left or right neighbour, and overall, across all the files, we have</span><br><span class="line">%% ((the amount of garbage) / (the sum of all file sizes)) &gt;</span><br><span class="line">%% ?GARBAGE_FRACTION, we start a garbage collection run concurrently,</span><br><span class="line">%% which will compact the two files together. </span><br><span class="line">当发现文件是空,我们会删除他.当我们发现文件可以和自己的左右邻居合并</span><br><span class="line">当garbage 数量与所有文件大</span><br><span class="line">小的比例超过一定阈值,会开始垃圾回收</span><br><span class="line"></span><br><span class="line">This keeps disk</span><br><span class="line">%% utilisation high and aids performance. We deliberately do this</span><br><span class="line">%% lazily in order to prevent doing GC on files which are soon to be</span><br><span class="line">%% emptied (and hence deleted).</span><br><span class="line"></span><br><span class="line">%% Given the compaction between two files, the left file (i.e. elder</span><br><span class="line">%% file) is considered the ultimate destination for the good data in</span><br><span class="line">%% the right file. If necessary, the good data in the left file which</span><br><span class="line">%% is fragmented throughout the file is written out to a temporary</span><br><span class="line">%% file, then read back in to form a contiguous chunk of good data at</span><br><span class="line">%% the start of the left file. Thus the left file is garbage collected</span><br><span class="line">%% and compacted. Then the good data from the right file is copied</span><br><span class="line">%% onto the end of the left file. Index and file summary tables are</span><br><span class="line">%% updated.</span><br><span class="line">%%</span><br><span class="line">%% On non-clean startup, we scan the files we discover, dealing with</span><br><span class="line">%% the possibilities of a crash having occurred during a compaction</span><br><span class="line">%% (this consists of tidyup - the compaction is deliberately designed</span><br><span class="line">%% such that data is duplicated on disk rather than risking it being</span><br><span class="line">%% lost), and rebuild the file summary and index ETS table.</span><br><span class="line">%%</span><br><span class="line">%% So, with this design, messages move to the left. Eventually, they</span><br><span class="line">%% should end up in a contiguous block on the left and are then never</span><br><span class="line">%% rewritten. But this isn&#x27;t quite the case. If in a file there is one</span><br><span class="line">%% message that is being ignored, for some reason, and messages in the</span><br><span class="line">%% file to the right and in the current block are being read all the</span><br><span class="line">%% time then it will repeatedly be the case that the good data from</span><br><span class="line">%% both files can be combined and will be written out to a new</span><br><span class="line">%% file. Whenever this happens, our shunned message will be rewritten.</span><br><span class="line">%%</span><br><span class="line">%% So, provided that we combine messages in the right order,</span><br><span class="line">%% (i.e. left file, bottom to top, right file, bottom to top),</span><br><span class="line">%% eventually our shunned message will end up at the bottom of the</span><br><span class="line">%% left file. The compaction/combining algorithm is smart enough to</span><br><span class="line">%% read in good data from the left file that is scattered throughout</span><br><span class="line">%% (i.e. C and D in the below diagram), then truncate the file to just</span><br><span class="line">%% above B (i.e. truncate to the limit of the good contiguous region</span><br><span class="line">%% at the start of the file), then write C and D on top and then write</span><br><span class="line">%% E, F and G from the right file on top. Thus contiguous blocks of</span><br><span class="line">%% good data at the bottom of files are not rewritten.</span><br><span class="line">%%</span><br><span class="line">%% +-------+    +-------+         +-------+</span><br><span class="line">%% |   X   |    |   G   |         |   G   |</span><br><span class="line">%% +-------+    +-------+         +-------+</span><br><span class="line">%% |   D   |    |   X   |         |   F   |</span><br><span class="line">%% +-------+    +-------+         +-------+</span><br><span class="line">%% |   X   |    |   X   |         |   E   |</span><br><span class="line">%% +-------+    +-------+         +-------+</span><br><span class="line">%% |   C   |    |   F   |   ===&gt;  |   D   |</span><br><span class="line">%% +-------+    +-------+         +-------+</span><br><span class="line">%% |   X   |    |   X   |         |   C   |</span><br><span class="line">%% +-------+    +-------+         +-------+</span><br><span class="line">%% |   B   |    |   X   |         |   B   |</span><br><span class="line">%% +-------+    +-------+         +-------+</span><br><span class="line">%% |   A   |    |   E   |         |   A   |</span><br><span class="line">%% +-------+    +-------+         +-------+</span><br><span class="line">%%   left         right             left</span><br><span class="line">%%</span><br><span class="line">%% From this reasoning, we do have a bound on the number of times the</span><br><span class="line">%% message is rewritten. From when it is inserted, there can be no</span><br><span class="line">%% files inserted between it and the head of the queue, and the worst</span><br><span class="line">%% case is that every time it is rewritten, it moves one position lower</span><br><span class="line">%% in the file (for it to stay at the same position requires that</span><br><span class="line">%% there are no holes beneath it, which means truncate would be used</span><br><span class="line">%% and so it would not be rewritten at all). Thus this seems to</span><br><span class="line">%% suggest the limit is the number of messages ahead of it in the</span><br><span class="line">%% queue, though it&#x27;s likely that that&#x27;s pessimistic, given the</span><br><span class="line">%% requirements for compaction/combination of files.</span><br><span class="line">%%</span><br><span class="line">%% The other property that we have is the bound on the lowest</span><br><span class="line">%% utilisation, which should be 50% - worst case is that all files are</span><br><span class="line">%% fractionally over half full and can&#x27;t be combined (equivalent is</span><br><span class="line">%% alternating full files and files with only one tiny message in</span><br><span class="line">%% them).</span><br><span class="line">%%</span><br><span class="line">%% Messages are reference-counted. When a message with the same msg id</span><br><span class="line">%% is written several times we only store it once, and only remove it</span><br><span class="line">%% from the store when it has been removed the same number of times.</span><br><span class="line">%%</span><br><span class="line">%% The reference counts do not persist. Therefore the initialisation</span><br><span class="line">%% function must be provided with a generator that produces ref count</span><br><span class="line">%% deltas for all recovered messages. This is only used on startup</span><br><span class="line">%% when the shutdown was non-clean.</span><br><span class="line">%%</span><br><span class="line">%% Read messages with a reference count greater than one are entered</span><br><span class="line">%% into a message cache. The purpose of the cache is not especially</span><br><span class="line">%% performance, though it can help there too, but prevention of memory</span><br><span class="line">%% explosion. It ensures that as messages with a high reference count</span><br><span class="line">%% are read from several processes they are read back as the same</span><br><span class="line">%% binary object rather than multiples of identical binary</span><br><span class="line">%% objects.</span><br><span class="line">%%</span><br><span class="line">%% Reads can be performed directly by clients without calling to the</span><br><span class="line">%% server. This is safe because multiple file handles can be used to</span><br><span class="line">%% read files. However, locking is used by the concurrent GC to make</span><br><span class="line">%% sure that reads are not attempted from files which are in the</span><br><span class="line">%% process of being garbage collected.</span><br><span class="line">%%</span><br><span class="line">%% When a message is removed, its reference count is decremented. Even</span><br><span class="line">%% if the reference count becomes 0, its entry is not removed. This is</span><br><span class="line">%% because in the event of the same message being sent to several</span><br><span class="line">%% different queues, there is the possibility of one queue writing and</span><br><span class="line">%% removing the message before other queues write it at all. Thus</span><br><span class="line">%% accommodating 0-reference counts allows us to avoid unnecessary</span><br><span class="line">%% writes here. Of course, there are complications: the file to which</span><br><span class="line">%% the message has already been written could be locked pending</span><br><span class="line">%% deletion or GC, which means we have to rewrite the message as the</span><br><span class="line">%% original copy will now be lost.</span><br><span class="line">%%</span><br><span class="line">%% The server automatically defers reads, removes and contains calls</span><br><span class="line">%% that occur which refer to files which are currently being</span><br><span class="line">%% GC&#x27;d. Contains calls are only deferred in order to ensure they do</span><br><span class="line">%% not overtake removes.</span><br><span class="line">%%</span><br><span class="line">%% The current file to which messages are being written has a</span><br><span class="line">%% write-back cache. This is written to immediately by clients and can</span><br><span class="line">%% be read from by clients too. This means that there are only ever</span><br><span class="line">%% writes made to the current file, thus eliminating delays due to</span><br><span class="line">%% flushing write buffers in order to be able to safely read from the</span><br><span class="line">%% current file. The one exception to this is that on start up, the</span><br><span class="line">%% cache is not populated with msgs found in the current file, and</span><br><span class="line">%% thus in this case only, reads may have to come from the file</span><br><span class="line">%% itself. The effect of this is that even if the msg_store process is</span><br><span class="line">%% heavily overloaded, clients can still write and read messages with</span><br><span class="line">%% very low latency and not block at all.</span><br><span class="line">%%</span><br><span class="line">%% Clients of the msg_store are required to register before using the</span><br><span class="line">%% msg_store. This provides them with the necessary client-side state</span><br><span class="line">%% to allow them to directly access the various caches and files. When</span><br><span class="line">%% they terminate, they should deregister. They can do this by calling</span><br><span class="line">%% either client_terminate/1 or client_delete_and_terminate/1. The</span><br><span class="line">%% differences are: (a) client_terminate is synchronous. As a result,</span><br><span class="line">%% if the msg_store is badly overloaded and has lots of in-flight</span><br><span class="line">%% writes and removes to process, this will take some time to</span><br><span class="line">%% return. However, once it does return, you can be sure that all the</span><br><span class="line">%% actions you&#x27;ve issued to the msg_store have been processed. (b) Not</span><br><span class="line">%% only is client_delete_and_terminate/1 asynchronous, but it also</span><br><span class="line">%% permits writes and subsequent removes from the current</span><br><span class="line">%% (terminating) client which are still in flight to be safely</span><br><span class="line">%% ignored. Thus from the point of view of the msg_store itself, and</span><br><span class="line">%% all from the same client:</span><br><span class="line">%%</span><br><span class="line">%% (T) = termination; (WN) = write of msg N; (RN) = remove of msg N</span><br><span class="line">%% --&gt; W1, W2, W1, R1, T, W3, R2, W2, R1, R2, R3, W4 --&gt;</span><br><span class="line">%%</span><br><span class="line">%% The client obviously sent T after all the other messages (up to</span><br><span class="line">%% W4), but because the msg_store prioritises messages, the T can be</span><br><span class="line">%% promoted and thus received early.</span><br><span class="line">%%</span><br><span class="line">%% Thus at the point of the msg_store receiving T, we have messages 1</span><br><span class="line">%% and 2 with a refcount of 1. After T, W3 will be ignored because</span><br><span class="line">%% it&#x27;s an unknown message, as will R3, and W4. W2, R1 and R2 won&#x27;t be</span><br><span class="line">%% ignored because the messages that they refer to were already known</span><br><span class="line">%% to the msg_store prior to T. However, it can be a little more</span><br><span class="line">%% complex: after the first R2, the refcount of msg 2 is 0. At that</span><br><span class="line">%% point, if a GC occurs or file deletion, msg 2 could vanish, which</span><br><span class="line">%% would then mean that the subsequent W2 and R2 are then ignored.</span><br><span class="line">%%</span><br><span class="line">%% The use case then for client_delete_and_terminate/1 is if the</span><br><span class="line">%% client wishes to remove everything it&#x27;s written to the msg_store:</span><br><span class="line">%% it issues removes for all messages it&#x27;s written and not removed,</span><br><span class="line">%% and then calls client_delete_and_terminate/1. At that point, any</span><br><span class="line">%% in-flight writes (and subsequent removes) can be ignored, but</span><br><span class="line">%% removes and writes for messages the msg_store already knows about</span><br><span class="line">%% will continue to be processed normally (which will normally just</span><br><span class="line">%% involve modifying the reference count, which is fast). Thus we save</span><br><span class="line">%% disk bandwidth for writes which are going to be immediately removed</span><br><span class="line">%% again by the the terminating client.</span><br><span class="line">%%</span><br><span class="line">%% We use a separate set to keep track of the dying clients in order</span><br><span class="line">%% to keep that set, which is inspected on every write and remove, as</span><br><span class="line">%% small as possible. Inspecting the set of all clients would degrade</span><br><span class="line">%% performance with many healthy clients and few, if any, dying</span><br><span class="line">%% clients, which is the typical case.</span><br><span class="line">%%</span><br><span class="line">%% Client termination messages are stored in a separate ets index to</span><br><span class="line">%% avoid filling primary message store index and message files with</span><br><span class="line">%% client termination messages.</span><br><span class="line">%%</span><br><span class="line">%% When the msg_store has a backlog (i.e. it has unprocessed messages</span><br><span class="line">%% in its mailbox / gen_server priority queue), a further optimisation</span><br><span class="line">%% opportunity arises: we can eliminate pairs of &#x27;write&#x27; and &#x27;remove&#x27;</span><br><span class="line">%% from the same client for the same message. A typical occurrence of</span><br><span class="line">%% these is when an empty durable queue delivers persistent messages</span><br><span class="line">%% to ack&#x27;ing consumers. The queue will asynchronously ask the</span><br><span class="line">%% msg_store to &#x27;write&#x27; such messages, and when they are acknowledged</span><br><span class="line">%% it will issue a &#x27;remove&#x27;. That &#x27;remove&#x27; may be issued before the</span><br><span class="line">%% msg_store has processed the &#x27;write&#x27;. There is then no point going</span><br><span class="line">%% ahead with the processing of that &#x27;write&#x27;.</span><br><span class="line">%%</span><br><span class="line">%% To detect this situation a &#x27;flying_ets&#x27; table is shared between the</span><br><span class="line">%% clients and the server. The table is keyed on the combination of</span><br><span class="line">%% client (reference) and msg id, and the value represents an</span><br><span class="line">%% integration of all the writes and removes currently &quot;in flight&quot; for</span><br><span class="line">%% that message between the client and server - &#x27;+1&#x27; means all the</span><br><span class="line">%% writes/removes add up to a single &#x27;write&#x27;, &#x27;-1&#x27; to a &#x27;remove&#x27;, and</span><br><span class="line">%% &#x27;0&#x27; to nothing. (NB: the integration can never add up to more than</span><br><span class="line">%% one &#x27;write&#x27; or &#x27;read&#x27; since clients must not write/remove a message</span><br><span class="line">%% more than once without first removing/writing it).</span><br><span class="line">%%</span><br><span class="line">%% Maintaining this table poses two challenges: 1) both the clients</span><br><span class="line">%% and the server access and update the table, which causes</span><br><span class="line">%% concurrency issues, 2) we must ensure that entries do not stay in</span><br><span class="line">%% the table forever, since that would constitute a memory leak. We</span><br><span class="line">%% address the former by carefully modelling all operations as</span><br><span class="line">%% sequences of atomic actions that produce valid results in all</span><br><span class="line">%% possible interleavings. We address the latter by deleting table</span><br><span class="line">%% entries whenever the server finds a 0-valued entry during the</span><br><span class="line">%% processing of a write/remove. 0 is essentially equivalent to &quot;no</span><br><span class="line">%% entry&quot;. If, OTOH, the value is non-zero we know there is at least</span><br><span class="line">%% one other &#x27;write&#x27; or &#x27;remove&#x27; in flight, so we get an opportunity</span><br><span class="line">%% later to delete the table entry when processing these.</span><br><span class="line">%%</span><br><span class="line">%% There are two further complications. We need to ensure that 1)</span><br><span class="line">%% eliminated writes still get confirmed, and 2) the write-back cache</span><br><span class="line">%% doesn&#x27;t grow unbounded. These are quite straightforward to</span><br><span class="line">%% address. See the comments in the code.</span><br><span class="line">%%</span><br><span class="line">%% For notes on Clean Shutdown and startup, see documentation in</span><br><span class="line">%% rabbit_variable_queue.</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shakudada.xyz/2021/11/04/rabbitmq%E5%BF%83%E8%B7%B3%E9%97%AE%E9%A2%98%E5%92%8Cphp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dinosaur">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dinosaur">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/04/rabbitmq%E5%BF%83%E8%B7%B3%E9%97%AE%E9%A2%98%E5%92%8Cphp/" class="post-title-link" itemprop="url">rabbitmq心跳问题和php</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-04 12:36:07" itemprop="dateCreated datePublished" datetime="2021-11-04T12:36:07+08:00">2021-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 11:42:47" itemprop="dateModified" datetime="2023-10-25T11:42:47+08:00">2023-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="为什么我们需要心跳"><a href="#为什么我们需要心跳" class="headerlink" title="为什么我们需要心跳"></a>为什么我们需要心跳</h3><p>tcp 靠的是什么保证链接? </p>
<p>序列号和重传,这是传输层的事情,但是对于应用层来说,是感知不到对端断开的,所以需要应用层的心跳.</p>
<h3 id="php的心跳有什么问题"><a href="#php的心跳有什么问题" class="headerlink" title="php的心跳有什么问题?"></a>php的心跳有什么问题?</h3><p>php大部分都是单进程模型,所以没有一个额外的线程去定时给这个tcp链接发一个心跳包,导致一旦运行比较长的时间(心跳时间*2),对端的rabbitmq会断开连接</p>
<p>所以大部分场景我们需要保证我们的运行时间小于心跳时间 , 不然会有<code>pipe broken</code>的问题,其实这个问题一般是超过心跳时间,导致rabbitmq 手动断开tcp连接了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shakudada.xyz/2021/10/21/lucence%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dinosaur">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dinosaur">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/21/lucence%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">lucene源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-21 13:01:36" itemprop="dateCreated datePublished" datetime="2021-10-21T13:01:36+08:00">2021-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 11:42:47" itemprop="dateModified" datetime="2023-10-25T11:42:47+08:00">2023-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>lucene 分为两部分：</p>
<ul>
<li><p>写入<br>写入则是写入文件系统</p>
</li>
<li><p>查询<br>则是通过了 分词、排序、topk提取等过程，获取对应的docid，再通过docid 回查对应的内容</p>
</li>
</ul>
<h2 id="Vint"><a href="#Vint" class="headerlink" title="Vint"></a>Vint</h2><p>vint 是一个可变长的数组，是一个小端的变长数组，每个字节最高位置<code>1</code>代表后面还有（也就是最后一个字节的最高位是0）</p>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IndexWriterConfig iwc = new IndexWriterConfig(analyzer);</span><br><span class="line">iwc.setUseCompoundFile(false);  // 生成多个文件</span><br></pre></td></tr></table></figure>

<h3 id="开始debug"><a href="#开始debug" class="headerlink" title="开始debug"></a>开始debug</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### 调试java 代码</span><br><span class="line"></span><br><span class="line"> java -agentlib:jdwp=transport=dt_socket,server=y,address=8000 -cp  ./lucene-demo-9.1.0-SNAPSHOT.jar:/home/ubuntu/lucene-9.1.0/lucene/core/build/libs/lucene-core-9.1.0-SNAPSHOT.jar:/home/ubuntu/lucene-9.1.0/lucene/queryparser/build/libs/lucene-queryparser-9.1.0-SNAPSHOT.jar    org.apache.lucene.demo.SearchFiles</span><br><span class="line"></span><br><span class="line">### jdb 连接上jdk</span><br><span class="line">jdb -attach 8000 -sourcepath /home/ubuntu/lucene-9.1.0/lucene/demo/src/java/</span><br></pre></td></tr></table></figure>

<h2 id="查看fdt文件"><a href="#查看fdt文件" class="headerlink" title="查看fdt文件"></a>查看fdt文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C _0.fdt</span><br><span class="line">00000000  3f d7 6c 17 1c 4c 75 63  65 6e 65 39 30 53 74 6f  |?.l..Lucene90Sto|</span><br><span class="line">00000010  72 65 64 46 69 65 6c 64  73 46 61 73 74 44 61 74  |redFieldsFastDat|</span><br><span class="line">00000020  61 00 00 00 01 85 88 12  2b 0c 73 6b 95 30 38 76  |a.......+.sk.08v|</span><br><span class="line">00000030  c9 0a 2a 52 29 00 00 0a  00 01 00 1c 02 06 03 07  |..*R)...........|</span><br><span class="line">00000040  07 07 07 07 07 07 07 07  20 00 1a 60 2f 68 6f 6d  |........ ..`/hom|</span><br><span class="line">00000050  65 2f 60 75 62 75 6e 74  75 60 2f 64 6f 63 2f 6d  |e/`ubuntu`/doc/m|</span><br><span class="line">00000060  60 6f 6e 67 6f 2e 74 60  78 74 00 1a 2f 68 60 6f  |`ongo.t`xt../h`o|</span><br><span class="line">00000070  6d 65 2f 75 62 60 75 6e  74 75 2f 64 60 6f 63 2f  |me/ub`untu/d`oc/|</span><br><span class="line">00000080  68 65 6c 60 6c 6f 2e 74  78 74 c0 28 93 e8 00 00  |hel`lo.txt.(....|</span><br><span class="line">00000090  00 00 00 00 00 00 c8 75  0a 41                    |.......u.A|</span><br><span class="line">0000009a</span><br></pre></td></tr></table></figure>
<h2 id="writeField"><a href="#writeField" class="headerlink" title="writeField"></a>writeField</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~$ jdb -attach 8000 -sourcepath /home/ubuntu/lucene-9.1.0/lucene/demo/src/java/:/home/ubuntu/lucene-9.1.0/lucene/core/src/java/ </span><br><span class="line">Set uncaught java.lang.Throwable</span><br><span class="line">Set deferred uncaught java.lang.Throwable</span><br><span class="line">Initializing jdb ...</span><br><span class="line">&gt; </span><br><span class="line">VM Started: No frames on the current call stack</span><br><span class="line"></span><br><span class="line">main[1] stop in  org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsWriter.writeField</span><br><span class="line">Deferring breakpoint org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsWriter.writeField.</span><br><span class="line">It will be set after the class is loaded.</span><br><span class="line">main[1] cont</span><br><span class="line">&gt; Set deferred breakpoint org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsWriter.writeField</span><br><span class="line"></span><br><span class="line">Breakpoint hit: &quot;thread=main&quot;, org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsWriter.writeField(), line=276 bci=0</span><br><span class="line">276        ++numStoredFieldsInDoc;</span><br><span class="line"></span><br><span class="line">main[1] wheree^H^H</span><br><span class="line">Unrecognized command: &#x27;wher&#x27;.  Try help...</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsWriter.writeField (Lucene90CompressingStoredFieldsWriter.java:276)</span><br><span class="line">  [2] org.apache.lucene.index.StoredFieldsConsumer.writeField (StoredFieldsConsumer.java:65)</span><br><span class="line">  [3] org.apache.lucene.index.IndexingChain.processField (IndexingChain.java:749)</span><br><span class="line">  [4] org.apache.lucene.index.IndexingChain.processDocument (IndexingChain.java:620)</span><br><span class="line">  [5] org.apache.lucene.index.DocumentsWriterPerThread.updateDocuments (DocumentsWriterPerThread.java:241)</span><br><span class="line">  [6] org.apache.lucene.index.DocumentsWriter.updateDocuments (DocumentsWriter.java:432)</span><br><span class="line">  [7] org.apache.lucene.index.IndexWriter.updateDocuments (IndexWriter.java:1,531)</span><br><span class="line">  [8] org.apache.lucene.index.IndexWriter.updateDocument (IndexWriter.java:1,816)</span><br><span class="line">  [9] org.apache.lucene.index.IndexWriter.addDocument (IndexWriter.java:1,469)</span><br><span class="line">  [10] org.apache.lucene.demo.IndexFiles.indexDoc (IndexFiles.java:271)</span><br><span class="line">  [11] org.apache.lucene.demo.IndexFiles$1.visitFile (IndexFiles.java:212)</span><br><span class="line">  [12] org.apache.lucene.demo.IndexFiles$1.visitFile (IndexFiles.java:208)</span><br><span class="line">  [13] java.nio.file.Files.walkFileTree (Files.java:2,725)</span><br><span class="line">  [14] java.nio.file.Files.walkFileTree (Files.java:2,797)</span><br><span class="line">  [15] org.apache.lucene.demo.IndexFiles.indexDocs (IndexFiles.java:206)</span><br><span class="line">  [16] org.apache.lucene.demo.IndexFiles.main (IndexFiles.java:157)</span><br><span class="line">main[1] list</span><br><span class="line">272    </span><br><span class="line">273      @Override</span><br><span class="line">274      public void writeField(FieldInfo info, IndexableField field) throws IOException &#123;</span><br><span class="line">275    </span><br><span class="line">276 =&gt;     ++numStoredFieldsInDoc;</span><br><span class="line">277    </span><br><span class="line">278        int bits = 0;</span><br><span class="line">279        final BytesRef bytes;</span><br><span class="line">280        final String string;</span><br><span class="line">281    </span><br><span class="line">main[1] print field</span><br><span class="line"> field = &quot;stored,indexed,omitNorms,indexOptions=DOCS&lt;path:/home/ubuntu/doc/mongo.txt&gt;&quot;</span><br><span class="line">main[1] print info</span><br><span class="line"> info = &quot;org.apache.lucene.index.FieldInfo@32464a14&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分词和倒排索引"><a href="#分词和倒排索引" class="headerlink" title="分词和倒排索引"></a>分词和倒排索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.index.IndexingChain$PerField.invert (IndexingChain.java:1,138)</span><br><span class="line">  [2] org.apache.lucene.index.IndexingChain.processField (IndexingChain.java:729)</span><br><span class="line">  [3] org.apache.lucene.index.IndexingChain.processDocument (IndexingChain.java:620)</span><br><span class="line">  [4] org.apache.lucene.index.DocumentsWriterPerThread.updateDocuments (DocumentsWriterPerThread.java:241)</span><br><span class="line">  [5] org.apache.lucene.index.DocumentsWriter.updateDocuments (DocumentsWriter.java:432)</span><br><span class="line">  [6] org.apache.lucene.index.IndexWriter.updateDocuments (IndexWriter.java:1,531)</span><br><span class="line">  [7] org.apache.lucene.index.IndexWriter.updateDocument (IndexWriter.java:1,816)</span><br><span class="line">  [8] org.apache.lucene.demo.IndexFiles.indexDoc (IndexFiles.java:277)</span><br><span class="line">  [9] org.apache.lucene.demo.IndexFiles$1.visitFile (IndexFiles.java:212)</span><br><span class="line">  [10] org.apache.lucene.demo.IndexFiles$1.visitFile (IndexFiles.java:208)</span><br><span class="line">  [11] java.nio.file.Files.walkFileTree (Files.java:2,725)</span><br><span class="line">  [12] java.nio.file.Files.walkFileTree (Files.java:2,797)</span><br><span class="line">  [13] org.apache.lucene.demo.IndexFiles.indexDocs (IndexFiles.java:206)</span><br><span class="line">  [14] org.apache.lucene.demo.IndexFiles.main (IndexFiles.java:157)</span><br></pre></td></tr></table></figure>

<h3 id="term描述"><a href="#term描述" class="headerlink" title="term描述"></a>term描述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntBlockPool intPool,</span><br><span class="line">ByteBlockPool bytePool,</span><br><span class="line">ByteBlockPool termBytePool,</span><br></pre></td></tr></table></figure>

<p>倒排索引term 在内存中用以下内容描述：<br><code>intPool</code> 包含三个变量:</p>
<ul>
<li>二维数组<code>buffers[][]</code></li>
<li><code>int bufferUpto</code> 描述的是二维数组 <code>buffers[][]</code>的第一级的偏移 ， 一般都是这样用 <code>int[]  buff = buffers[bufferUpto + offset]</code></li>
<li><code>int intUpto</code> 描述的是整体的偏移量,描述是偏移所有的buffers 的字节数</li>
<li><code>int intOffset</code> 描述的是<code>header buffer</code>的偏移量</li>
</ul>
<p>那么<code>buffers[xxx][yyy]</code>的值又是什么呢？<br>这个<code>buffers</code>二维数组存的也是偏移量.是什么的偏移量呢？</p>
<p><code>intPool</code>描述的是<code>bytePool</code> 和<code>termBytePool</code> 的偏移量</p>
<h3 id="term-写入tim文件"><a href="#term-写入tim文件" class="headerlink" title="term 写入tim文件"></a>term 写入tim文件</h3><p>会将term一个个写入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main[1] where </span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.blocktree.Lucene90BlockTreeTermsWriter$TermsWriter.writeBlock (Lucene90BlockTreeTermsWriter.java:963)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.blocktree.Lucene90BlockTreeTermsWriter$TermsWriter.writeBlocks (Lucene90BlockTreeTermsWriter.java:709)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.blocktree.Lucene90BlockTreeTermsWriter$TermsWriter.finish (Lucene90BlockTreeTermsWriter.java:1,105)</span><br><span class="line">  [4] org.apache.lucene.codecs.lucene90.blocktree.Lucene90BlockTreeTermsWriter.write (Lucene90BlockTreeTermsWriter.java:370)</span><br><span class="line">  [5] org.apache.lucene.codecs.perfield.PerFieldPostingsFormat$FieldsWriter.write (PerFieldPostingsFormat.java:171)</span><br><span class="line">  [6] org.apache.lucene.index.FreqProxTermsWriter.flush (FreqProxTermsWriter.java:131)</span><br><span class="line">  [7] org.apache.lucene.index.IndexingChain.flush (IndexingChain.java:300)</span><br><span class="line">  [8] org.apache.lucene.index.DocumentsWriterPerThread.flush (DocumentsWriterPerThread.java:391)</span><br><span class="line">  [9] org.apache.lucene.index.DocumentsWriter.doFlush (DocumentsWriter.java:493)</span><br><span class="line">  [10] org.apache.lucene.index.DocumentsWriter.flushAllThreads (DocumentsWriter.java:672)</span><br><span class="line">  [11] org.apache.lucene.index.IndexWriter.doFlush (IndexWriter.java:4,014)</span><br><span class="line">  [12] org.apache.lucene.index.IndexWriter.flush (IndexWriter.java:3,988)</span><br><span class="line">  [13] org.apache.lucene.index.IndexWriter.shutdown (IndexWriter.java:1,321)</span><br><span class="line">  [14] org.apache.lucene.index.IndexWriter.close (IndexWriter.java:1,361)</span><br><span class="line">  [15] org.apache.lucene.demo.IndexFiles.main (IndexFiles.java:166)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.TopScoreDocCollector$SimpleTopScoreDocCollector.getLeafCollector (TopScoreDocCollector.java:57)</span><br><span class="line">  [2] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:759)</span><br><span class="line">  [3] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [7] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [8] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="获取term"><a href="#获取term" class="headerlink" title="获取term"></a>获取term</h3><p>从terms reader 读取term</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main[1] print fieldMap.get(field)</span><br><span class="line"> fieldMap.get(field) = &quot;BlockTreeTerms(seg=_j terms=18,postings=20,positions=25,docs=2)&quot;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.blocktree.Lucene90BlockTreeTermsReader.terms (Lucene90BlockTreeTermsReader.java:294)</span><br><span class="line">  [2] org.apache.lucene.codecs.perfield.PerFieldPostingsFormat$FieldsReader.terms (PerFieldPostingsFormat.java:353)</span><br><span class="line">  [3] org.apache.lucene.index.CodecReader.terms (CodecReader.java:114)</span><br><span class="line">  [4] org.apache.lucene.index.Terms.getTerms (Terms.java:41)</span><br><span class="line">  [5] org.apache.lucene.index.TermStates.loadTermsEnum (TermStates.java:115)</span><br><span class="line">  [6] org.apache.lucene.index.TermStates.build (TermStates.java:102)</span><br><span class="line">  [7] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [10] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [11] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [12] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [13] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="通过arc-获取对应output"><a href="#通过arc-获取对应output" class="headerlink" title="通过arc 获取对应output"></a>通过arc 获取对应output</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hit: &quot;thread=main&quot;, org.apache.lucene.util.fst.FST.findTargetArc(), line=1,412 bci=0</span><br><span class="line">1,412        if (labelToMatch == END_LABEL) &#123;</span><br><span class="line"></span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.util.fst.FST.findTargetArc (FST.java:1,412)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.seekExact (SegmentTermsEnum.java:511)</span><br><span class="line">  [3] org.apache.lucene.index.TermStates.loadTermsEnum (TermStates.java:117)</span><br><span class="line">  [4] org.apache.lucene.index.TermStates.build (TermStates.java:102)</span><br><span class="line">  [5] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="打开tim文件"><a href="#打开tim文件" class="headerlink" title="打开tim文件"></a>打开tim文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.blocktree.Lucene90BlockTreeTermsReader.&lt;init&gt; (Lucene90BlockTreeTermsReader.java:135)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.Lucene90PostingsFormat.fieldsProducer (Lucene90PostingsFormat.java:427)</span><br><span class="line">  [3] org.apache.lucene.codecs.perfield.PerFieldPostingsFormat$FieldsReader.&lt;init&gt; (PerFieldPostingsFormat.java:329)</span><br><span class="line">  [4] org.apache.lucene.codecs.perfield.PerFieldPostingsFormat.fieldsProducer (PerFieldPostingsFormat.java:391)</span><br><span class="line">  [5] org.apache.lucene.index.SegmentCoreReaders.&lt;init&gt; (SegmentCoreReaders.java:118)</span><br><span class="line">  [6] org.apache.lucene.index.SegmentReader.&lt;init&gt; (SegmentReader.java:91)</span><br><span class="line">  [7] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:94)</span><br><span class="line">  [8] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:77)</span><br><span class="line">  [9] org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run (SegmentInfos.java:809)</span><br><span class="line">  [10] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:109)</span><br><span class="line">  [11] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:67)</span><br><span class="line">  [12] org.apache.lucene.index.DirectoryReader.open (DirectoryReader.java:60)</span><br><span class="line">  [13] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:105)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取topk的数据核心函数<code>mergeAux</code>,一个辅助函数获取topk的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Step completed: &quot;thread=main&quot;, org.apache.lucene.search.TopDocs.mergeAux(), line=291 bci=43</span><br><span class="line">291        for (int shardIDX = 0; shardIDX &lt; shardHits.length; shardIDX++) &#123;</span><br><span class="line"></span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.TopDocs.mergeAux (TopDocs.java:291)</span><br><span class="line">  [2] org.apache.lucene.search.TopDocs.merge (TopDocs.java:216)</span><br><span class="line">  [3] org.apache.lucene.search.IndexSearcher$2.reduce (IndexSearcher.java:528)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher$2.reduce (IndexSearcher.java:505)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:694)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br></pre></td></tr></table></figure>






<h2 id="docid-获取对应的文案内容"><a href="#docid-获取对应的文案内容" class="headerlink" title="docid 获取对应的文案内容"></a><code>docid</code> 获取对应的文案内容</h2><h3 id="通过docid-获取document"><a href="#通过docid-获取document" class="headerlink" title="通过docid 获取document"></a>通过docid 获取document</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.store.ByteBufferIndexInput$SingleBufferImpl.seek (ByteBufferIndexInput.java:529)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader$BlockState.document (Lucene90CompressingStoredFieldsReader.java:594)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.document (Lucene90CompressingStoredFieldsReader.java:610)</span><br><span class="line">  [4] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.visitDocument (Lucene90CompressingStoredFieldsReader.java:628)</span><br><span class="line">  [5] org.apache.lucene.index.CodecReader.document (CodecReader.java:89)</span><br><span class="line">  [6] org.apache.lucene.index.BaseCompositeReader.document (BaseCompositeReader.java:154)</span><br><span class="line">  [7] org.apache.lucene.index.IndexReader.document (IndexReader.java:380)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.doc (IndexSearcher.java:380)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:214)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>
<p>seek 方法通过偏移获取document,其中seek 中<code>curBuf</code> 是<code>java.nio.DirectByteBufferR</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">525    </span><br><span class="line">526        @Override</span><br><span class="line">527        public void seek(long pos) throws IOException &#123;</span><br><span class="line">528          try &#123;</span><br><span class="line">529 =&gt;         curBuf.position((int) pos);</span><br><span class="line">530          &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">531            if (pos &lt; 0) &#123;</span><br><span class="line">532              throw new IllegalArgumentException(&quot;Seeking to negative position: &quot; + this, e);</span><br><span class="line">533            &#125; else &#123;</span><br><span class="line">534              throw new EOFException(&quot;seek past EOF: &quot; + this);</span><br><span class="line">main[1] print curBuf</span><br><span class="line"> curBuf = &quot;java.nio.DirectByteBufferR[pos=60 lim=154 cap=154]&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">168    </span><br><span class="line">169      // NOTE: AIOOBE not EOF if you read too much</span><br><span class="line">170      @Override</span><br><span class="line">171      public void readBytes(byte[] b, int offset, int len) &#123;</span><br><span class="line">172 =&gt;     System.arraycopy(bytes, pos, b, offset, len);</span><br><span class="line">173        pos += len;</span><br><span class="line">174      &#125;</span><br><span class="line">175    &#125;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.store.ByteArrayDataInput.readBytes (ByteArrayDataInput.java:172)</span><br><span class="line">  [2] org.apache.lucene.store.DataInput.readString (DataInput.java:265)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.readField (Lucene90CompressingStoredFieldsReader.java:246)</span><br><span class="line">  [4] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.visitDocument (Lucene90CompressingStoredFieldsReader.java:640)</span><br><span class="line">  [5] org.apache.lucene.index.CodecReader.document (CodecReader.java:89)</span><br><span class="line">  [6] org.apache.lucene.index.BaseCompositeReader.document (BaseCompositeReader.java:154)</span><br><span class="line">  [7] org.apache.lucene.index.IndexReader.document (IndexReader.java:380)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.doc (IndexSearcher.java:380)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:214)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>


<h3 id="通过堆外内存加载文件数据"><a href="#通过堆外内存加载文件数据" class="headerlink" title="通过堆外内存加载文件数据"></a>通过堆外内存加载文件数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hit: &quot;thread=main&quot;, org.apache.lucene.store.ByteBufferIndexInput.setCurBuf(), line=83 bci=0</span><br><span class="line">83        this.curBuf = curBuf;</span><br><span class="line"></span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.store.ByteBufferIndexInput.setCurBuf (ByteBufferIndexInput.java:83)</span><br><span class="line">  [2] org.apache.lucene.store.ByteBufferIndexInput$SingleBufferImpl.&lt;init&gt; (ByteBufferIndexInput.java:520)</span><br><span class="line">  [3] org.apache.lucene.store.ByteBufferIndexInput.newInstance (ByteBufferIndexInput.java:60)</span><br><span class="line">  [4] org.apache.lucene.store.MMapDirectory.openInput (MMapDirectory.java:238)</span><br><span class="line">  [5] org.apache.lucene.store.Directory.openChecksumInput (Directory.java:152)</span><br><span class="line">  [6] org.apache.lucene.index.SegmentInfos.readCommit (SegmentInfos.java:297)</span><br><span class="line">  [7] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:88)</span><br><span class="line">  [8] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:77)</span><br><span class="line">  [9] org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run (SegmentInfos.java:809)</span><br><span class="line">  [10] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:109)</span><br><span class="line">  [11] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:67)</span><br><span class="line">  [12] org.apache.lucene.index.DirectoryReader.open (DirectoryReader.java:60)</span><br><span class="line">  [13] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:105)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="filechannel-的-map"><a href="#filechannel-的-map" class="headerlink" title="filechannel 的 map"></a>filechannel 的 map</h3><p>java 对应的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src\java.base\share\classes\sun\nio\ch\FileChannelImpl.java</span><br><span class="line">    // Creates a new mapping</span><br><span class="line">    private native long map0(int prot, long position, long length, boolean isSync)</span><br><span class="line">        throws IOException;</span><br></pre></td></tr></table></figure>

<p>native 对应的c实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">src\java.base\unix\native\libnio\ch\FileChannelImpl.c</span><br><span class="line">JNIEXPORT jlong JNICALL</span><br><span class="line">Java_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject this,</span><br><span class="line">                                     jint prot, jlong off, jlong len, jboolean map_sync)</span><br><span class="line">&#123;</span><br><span class="line">    void *mapAddress = 0;</span><br><span class="line">    jobject fdo = (*env)-&gt;GetObjectField(env, this, chan_fd);</span><br><span class="line">    jint fd = fdval(env, fdo);</span><br><span class="line">    int protections = 0;</span><br><span class="line">    int flags = 0;</span><br><span class="line"></span><br><span class="line">    // should never be called with map_sync and prot == PRIVATE</span><br><span class="line">    assert((prot != sun_nio_ch_FileChannelImpl_MAP_PV) || !map_sync);</span><br><span class="line"></span><br><span class="line">    if (prot == sun_nio_ch_FileChannelImpl_MAP_RO) &#123;</span><br><span class="line">        protections = PROT_READ;</span><br><span class="line">        flags = MAP_SHARED;</span><br><span class="line">    &#125; else if (prot == sun_nio_ch_FileChannelImpl_MAP_RW) &#123;</span><br><span class="line">        protections = PROT_WRITE | PROT_READ;</span><br><span class="line">        flags = MAP_SHARED;</span><br><span class="line">    &#125; else if (prot == sun_nio_ch_FileChannelImpl_MAP_PV) &#123;</span><br><span class="line">        protections =  PROT_WRITE | PROT_READ;</span><br><span class="line">        flags = MAP_PRIVATE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // if MAP_SYNC and MAP_SHARED_VALIDATE are not defined then it is</span><br><span class="line">    // best to define them here. This ensures the code compiles on old</span><br><span class="line">    // OS releases which do not provide the relevant headers. If run</span><br><span class="line">    // on the same machine then it will work if the kernel contains</span><br><span class="line">    // the necessary support otherwise mmap should fail with an</span><br><span class="line">    // invalid argument error</span><br><span class="line"></span><br><span class="line">#ifndef MAP_SYNC</span><br><span class="line">#define MAP_SYNC 0x80000</span><br><span class="line">#endif</span><br><span class="line">#ifndef MAP_SHARED_VALIDATE</span><br><span class="line">#define MAP_SHARED_VALIDATE 0x03</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    if (map_sync) &#123;</span><br><span class="line">        // ensure</span><br><span class="line">        //  1) this is Linux on AArch64, x86_64, or PPC64 LE</span><br><span class="line">        //  2) the mmap APIs are available at compile time</span><br><span class="line">#if !defined(LINUX) || ! (defined(aarch64) || (defined(amd64) &amp;&amp; defined(_LP64)) || defined(ppc64le))</span><br><span class="line">        // TODO - implement for solaris/AIX/BSD/WINDOWS and for 32 bit</span><br><span class="line">        JNU_ThrowInternalError(env, &quot;should never call map on platform where MAP_SYNC is unimplemented&quot;);</span><br><span class="line">        return IOS_THROWN;</span><br><span class="line">#else</span><br><span class="line">        flags |= MAP_SYNC | MAP_SHARED_VALIDATE;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapAddress = mmap64(</span><br><span class="line">        0,                    /* Let OS decide location */</span><br><span class="line">        len,                  /* Number of bytes to map */</span><br><span class="line">        protections,          /* File permissions */</span><br><span class="line">        flags,                /* Changes are shared */</span><br><span class="line">        fd,                   /* File descriptor of mapped file */</span><br><span class="line">        off);                 /* Offset into file */</span><br><span class="line"></span><br><span class="line">    if (mapAddress == MAP_FAILED) &#123;</span><br><span class="line">        if (map_sync &amp;&amp; errno == ENOTSUP) &#123;</span><br><span class="line">            JNU_ThrowIOExceptionWithLastError(env, &quot;map with mode MAP_SYNC unsupported&quot;);</span><br><span class="line">            return IOS_THROWN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (errno == ENOMEM) &#123;</span><br><span class="line">            JNU_ThrowOutOfMemoryError(env, &quot;Map failed&quot;);</span><br><span class="line">            return IOS_THROWN;</span><br><span class="line">        &#125;</span><br><span class="line">        return handle(env, -1, &quot;Map failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ((jlong) (unsigned long) mapAddress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="mmap-映射文件读取硬盘中的内容"><a href="#mmap-映射文件读取硬盘中的内容" class="headerlink" title="mmap 映射文件读取硬盘中的内容"></a>mmap 映射文件读取硬盘中的内容</h4><p><code>FileChannel.open</code> 底层是一个native方法,如果是linux系统,就是<code>mmap64</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">228    </span><br><span class="line">229      /** Creates an IndexInput for the file with the given name. */</span><br><span class="line">230      @Override</span><br><span class="line">231      public IndexInput openInput(String name, IOContext context) throws IOException &#123;</span><br><span class="line">232 =&gt;     ensureOpen();</span><br><span class="line">233        ensureCanRead(name);</span><br><span class="line">234        Path path = directory.resolve(name);</span><br><span class="line">235        try (FileChannel c = FileChannel.open(path, StandardOpenOption.READ)) &#123;</span><br><span class="line">236          final String resourceDescription = &quot;MMapIndexInput(path=\&quot;&quot; + path.toString() + &quot;\&quot;)&quot;;</span><br><span class="line">237          final boolean useUnmap = getUseUnmap();</span><br><span class="line">main[1] print name</span><br><span class="line"> name = &quot;_j.fnm&quot;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.store.MMapDirectory.openInput (MMapDirectory.java:232)</span><br><span class="line">  [2] org.apache.lucene.store.Directory.openChecksumInput (Directory.java:152)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.Lucene90FieldInfosFormat.read (Lucene90FieldInfosFormat.java:124)</span><br><span class="line">  [4] org.apache.lucene.index.SegmentCoreReaders.&lt;init&gt; (SegmentCoreReaders.java:111)</span><br><span class="line">  [5] org.apache.lucene.index.SegmentReader.&lt;init&gt; (SegmentReader.java:91)</span><br><span class="line">  [6] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:94)</span><br><span class="line">  [7] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:77)</span><br><span class="line">  [8] org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run (SegmentInfos.java:809)</span><br><span class="line">  [9] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:109)</span><br><span class="line">  [10] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:67)</span><br><span class="line">  [11] org.apache.lucene.index.DirectoryReader.open (DirectoryReader.java:60)</span><br><span class="line">  [12] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:105)</span><br></pre></td></tr></table></figure>



<h4 id="读取mmap后的数据"><a href="#读取mmap后的数据" class="headerlink" title="读取mmap后的数据"></a>读取mmap后的数据</h4><p>mmap之后的buf在哪里会被用到呢?<br>和普通的文件读写类似,也就是seek后读字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">lucene\core\src\java\org\apache\lucene\store\ByteBufferIndexInput.java</span><br><span class="line">  @Override</span><br><span class="line">  public final void readBytes(byte[] b, int offset, int len) throws IOException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      guard.getBytes(curBuf, b, offset, len);</span><br><span class="line">    &#125; catch (</span><br><span class="line">        @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">        BufferUnderflowException e) &#123;</span><br><span class="line">      int curAvail = curBuf.remaining();</span><br><span class="line">      while (len &gt; curAvail) &#123;</span><br><span class="line">        guard.getBytes(curBuf, b, offset, curAvail);</span><br><span class="line">        len -= curAvail;</span><br><span class="line">        offset += curAvail;</span><br><span class="line">        curBufIndex++;</span><br><span class="line">        if (curBufIndex &gt;= buffers.length) &#123;</span><br><span class="line">          throw new EOFException(&quot;read past EOF: &quot; + this);</span><br><span class="line">        &#125;</span><br><span class="line">        setCurBuf(buffers[curBufIndex]);</span><br><span class="line">        curBuf.position(0);</span><br><span class="line">        curAvail = curBuf.remaining();</span><br><span class="line">      &#125;</span><br><span class="line">      guard.getBytes(curBuf, b, offset, len);</span><br><span class="line">    &#125; catch (</span><br><span class="line">        @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">        NullPointerException npe) &#123;</span><br><span class="line">      throw new AlreadyClosedException(&quot;Already closed: &quot; + this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>mmap后读取数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] jdk.internal.misc.Unsafe.copyMemory (Unsafe.java:782)</span><br><span class="line">  [2] java.nio.DirectByteBuffer.get (DirectByteBuffer.java:308)</span><br><span class="line">  [3] org.apache.lucene.store.ByteBufferGuard.getBytes (ByteBufferGuard.java:93)</span><br><span class="line">  [4] org.apache.lucene.store.ByteBufferIndexInput.readBytes (ByteBufferIndexInput.java:114)</span><br><span class="line">  [5] org.apache.lucene.store.BufferedChecksumIndexInput.readBytes (BufferedChecksumIndexInput.java:46)</span><br><span class="line">  [6] org.apache.lucene.store.DataInput.readString (DataInput.java:265)</span><br><span class="line">  [7] org.apache.lucene.codecs.CodecUtil.checkHeaderNoMagic (CodecUtil.java:202)</span><br><span class="line">  [8] org.apache.lucene.codecs.CodecUtil.checkHeader (CodecUtil.java:193)</span><br><span class="line">  [9] org.apache.lucene.codecs.CodecUtil.checkIndexHeader (CodecUtil.java:253)</span><br><span class="line">  [10] org.apache.lucene.codecs.lucene90.Lucene90FieldInfosFormat.read (Lucene90FieldInfosFormat.java:128)</span><br><span class="line">  [11] org.apache.lucene.index.SegmentCoreReaders.&lt;init&gt; (SegmentCoreReaders.java:111)</span><br><span class="line">  [12] org.apache.lucene.index.SegmentReader.&lt;init&gt; (SegmentReader.java:91)</span><br><span class="line">  [13] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:94)</span><br><span class="line">  [14] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:77)</span><br><span class="line">  [15] org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run (SegmentInfos.java:809)</span><br><span class="line">  [16] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:109)</span><br><span class="line">  [17] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:67)</span><br><span class="line">  [18] org.apache.lucene.index.DirectoryReader.open (DirectoryReader.java:60)</span><br><span class="line">  [19] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:105)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="文件格式介绍"><a href="#文件格式介绍" class="headerlink" title="文件格式介绍"></a>文件格式介绍</h2><h3 id="fnm-文件"><a href="#fnm-文件" class="headerlink" title=".fnm 文件"></a>.fnm 文件</h3><p><a target="_blank" rel="noopener" href="https://lucene.apache.org/core/9_0_0/core/org/apache/lucene/codecs/lucene90/Lucene90FieldInfosFormat.html">格式出处</a></p>
<p>fnm 文件 由这几部分组成:</p>
<ul>
<li>Header</li>
<li>FieldsCount : 字段的个数</li>
<li>数组,长度为FieldsCount , 数组中每个元素包含包含这几个字段: [FieldName: 字段名 ,FieldNumber:字段number ,FieldBits, DocValuesBits,  DocValuesGen ,DimensionCount , DimensionNumBytes ]</li>
<li>Footer</li>
</ul>
<p>fnm 描述的field的基础信息,也可以算是metadata信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">Field names are stored in the field info file, with suffix .fnm.</span><br><span class="line"></span><br><span class="line">FieldInfos (.fnm) --&gt; Header,FieldsCount, &lt;FieldName,FieldNumber, FieldBits,DocValuesBits,DocValuesGen,Attributes,DimensionCount,DimensionNumBytes&gt; ,Footer</span><br><span class="line"></span><br><span class="line">Data types:</span><br><span class="line"></span><br><span class="line">Header --&gt; IndexHeader</span><br><span class="line">FieldsCount --&gt; VInt</span><br><span class="line">FieldName --&gt; String</span><br><span class="line">FieldBits, IndexOptions, DocValuesBits --&gt; Byte</span><br><span class="line">FieldNumber, DimensionCount, DimensionNumBytes --&gt; VInt</span><br><span class="line">Attributes --&gt; Map&lt;String,String&gt;</span><br><span class="line">DocValuesGen --&gt; Int64</span><br><span class="line">Footer --&gt; CodecFooter</span><br><span class="line">Field Descriptions:</span><br><span class="line">FieldsCount: the number of fields in this file.</span><br><span class="line">FieldName: name of the field as a UTF-8 String.</span><br><span class="line">FieldNumber: the field&#x27;s number. Note that unlike previous versions of Lucene, the fields are not numbered implicitly by their order in the file, instead explicitly.</span><br><span class="line">FieldBits: a byte containing field options.</span><br><span class="line">The low order bit (0x1) is one for fields that have term vectors stored, and zero for fields without term vectors.</span><br><span class="line">If the second lowest order-bit is set (0x2), norms are omitted for the indexed field.</span><br><span class="line">If the third lowest-order bit is set (0x4), payloads are stored for the indexed field.</span><br><span class="line">IndexOptions: a byte containing index options.</span><br><span class="line">0: not indexed</span><br><span class="line">1: indexed as DOCS_ONLY</span><br><span class="line">2: indexed as DOCS_AND_FREQS</span><br><span class="line">3: indexed as DOCS_AND_FREQS_AND_POSITIONS</span><br><span class="line">4: indexed as DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS</span><br><span class="line">DocValuesBits: a byte containing per-document value types. The type recorded as two four-bit integers, with the high-order bits representing norms options, and the low-order bits representing DocValues options. Each four-bit integer can be decoded as such:</span><br><span class="line">0: no DocValues for this field.</span><br><span class="line">1: NumericDocValues. (DocValuesType.NUMERIC)</span><br><span class="line">2: BinaryDocValues. (DocValuesType#BINARY)</span><br><span class="line">3: SortedDocValues. (DocValuesType#SORTED)</span><br><span class="line">DocValuesGen is the generation count of the field&#x27;s DocValues. If this is -1, there are no DocValues updates to that field. Anything above zero means there are updates stored by DocValuesFormat.</span><br><span class="line">Attributes: a key-value map of codec-private attributes.</span><br><span class="line">PointDimensionCount, PointNumBytes: these are non-zero only if the field is indexed as points, e.g. using LongPoint</span><br><span class="line">VectorDimension: it is non-zero if the field is indexed as vectors.</span><br><span class="line">VectorSimilarityFunction: a byte containing distance function used for similarity calculation.</span><br><span class="line">0: EUCLIDEAN distance. (VectorSimilarityFunction.EUCLIDEAN)</span><br><span class="line">1: DOT_PRODUCT similarity. (VectorSimilarityFunction.DOT_PRODUCT)</span><br><span class="line">2: COSINE similarity. (VectorSimilarityFunction.COSINE)</span><br></pre></td></tr></table></figure>


<h3 id="fdt"><a href="#fdt" class="headerlink" title=".fdt"></a>.fdt</h3><p>文件路径: <code>lucene\backward-codecs\src\java\org\apache\lucene\backward_codecs\lucene50\Lucene50CompoundFormat.java</code>  </p>
<p>没有找到90的版本的fdt格式,只有2.9.4的,将就使用<a target="_blank" rel="noopener" href="https://lucene.apache.org/core/2_9_4/fileformats.html#field_data">fdt格式</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main[1] print fieldsStreamFN</span><br><span class="line"> fieldsStreamFN = &quot;_j.fdt&quot;</span><br><span class="line">main[1] list</span><br><span class="line">124        numDocs = si.maxDoc();</span><br><span class="line">125    </span><br><span class="line">126        final String fieldsStreamFN =</span><br><span class="line">127            IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION);</span><br><span class="line">128 =&gt;     ChecksumIndexInput metaIn = null;</span><br><span class="line">129        try &#123;</span><br><span class="line">130          // Open the data file</span><br><span class="line">131          fieldsStream = d.openInput(fieldsStreamFN, context);</span><br><span class="line">132          version =</span><br><span class="line">133              CodecUtil.checkIndexHeader(</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.&lt;init&gt; (Lucene90CompressingStoredFieldsReader.java:128)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsFormat.fieldsReader (Lucene90CompressingStoredFieldsFormat.java:133)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.Lucene90StoredFieldsFormat.fieldsReader (Lucene90StoredFieldsFormat.java:136)</span><br><span class="line">  [4] org.apache.lucene.index.SegmentCoreReaders.&lt;init&gt; (SegmentCoreReaders.java:138)</span><br><span class="line">  [5] org.apache.lucene.index.SegmentReader.&lt;init&gt; (SegmentReader.java:91)</span><br><span class="line">  [6] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:94)</span><br><span class="line">  [7] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:77)</span><br><span class="line">  [8] org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run (SegmentInfos.java:809)</span><br><span class="line">  [9] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:109)</span><br><span class="line">  [10] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:67)</span><br><span class="line">  [11] org.apache.lucene.index.DirectoryReader.open (DirectoryReader.java:60)</span><br><span class="line">  [12] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:105)</span><br></pre></td></tr></table></figure>


<h3 id="加载doc的内容到Document-对象"><a href="#加载doc的内容到Document-对象" class="headerlink" title="加载doc的内容到Document 对象"></a>加载doc的内容到Document 对象</h3><p>整个流程是通过docid 获取document 的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void visitDocument(int docID, StoredFieldVisitor visitor) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">  final SerializedDocument doc = document(docID);  // 通过docID 获取doc对象</span><br><span class="line"></span><br><span class="line">  for (int fieldIDX = 0; fieldIDX &lt; doc.numStoredFields; fieldIDX++) &#123;</span><br><span class="line">    final long infoAndBits = doc.in.readVLong();</span><br><span class="line">    final int fieldNumber = (int) (infoAndBits &gt;&gt;&gt; TYPE_BITS);</span><br><span class="line">    final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldNumber);</span><br><span class="line"></span><br><span class="line">    final int bits = (int) (infoAndBits &amp; TYPE_MASK);</span><br><span class="line">    assert bits &lt;= NUMERIC_DOUBLE : &quot;bits=&quot; + Integer.toHexString(bits);</span><br><span class="line"></span><br><span class="line">    switch (visitor.needsField(fieldInfo)) &#123;</span><br><span class="line">      case YES:</span><br><span class="line">        readField(doc.in, visitor, fieldInfo, bits);   // 通过input , 也就是input 绑定的fd ,去读mmap64 映射的文件 ,在这里会读取后缀名为 .fdt 的文件 </span><br><span class="line">        break;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.document.Document.add (Document.java:60)</span><br><span class="line">  [2] org.apache.lucene.document.DocumentStoredFieldVisitor.stringField (DocumentStoredFieldVisitor.java:74)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.readField (Lucene90CompressingStoredFieldsReader.java:246)</span><br><span class="line">  [4] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.visitDocument (Lucene90CompressingStoredFieldsReader.java:640)</span><br><span class="line">  [5] org.apache.lucene.index.CodecReader.document (CodecReader.java:89)</span><br><span class="line">  [6] org.apache.lucene.index.BaseCompositeReader.document (BaseCompositeReader.java:154)</span><br><span class="line">  [7] org.apache.lucene.index.IndexReader.document (IndexReader.java:380)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.doc (IndexSearcher.java:380)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:214)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="通过docid-构建-SerializedDocument"><a href="#通过docid-构建-SerializedDocument" class="headerlink" title="通过docid 构建 SerializedDocument"></a>通过docid 构建 SerializedDocument</h3><p>首先入口在这里: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.document</span><br></pre></td></tr></table></figure>
<p>Lucene90CompressingStoredFieldsReader的document 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.store.ByteBufferIndexInput$SingleBufferImpl.seek (ByteBufferIndexInput.java:529)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.document (Lucene90CompressingStoredFieldsReader.java:606)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.visitDocument (Lucene90CompressingStoredFieldsReader.java:628)</span><br><span class="line">  [4] org.apache.lucene.index.CodecReader.document (CodecReader.java:89)</span><br><span class="line">  [5] org.apache.lucene.index.BaseCompositeReader.document (BaseCompositeReader.java:154)</span><br><span class="line">  [6] org.apache.lucene.index.IndexReader.document (IndexReader.java:380)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.doc (IndexSearcher.java:380)</span><br><span class="line">  [8] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:214)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SerializedDocument document(int docID) throws IOException &#123;</span><br><span class="line">  if (state.contains(docID) == false) &#123;</span><br><span class="line">    fieldsStream.seek(indexReader.getStartPointer(docID)); // 通过mmap64 偏移</span><br><span class="line">    state.reset(docID);</span><br><span class="line">  &#125;</span><br><span class="line">  assert state.contains(docID);</span><br><span class="line">  return state.document(docID);    // 再看具体的实现 , 这个state 对象对应的类是一个静态内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看看静态内部类的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * Get the serialized representation of the given docID. This docID has to be contained in the</span><br><span class="line">   * current block.</span><br><span class="line">   */</span><br><span class="line">  SerializedDocument document(int docID) throws IOException &#123;</span><br><span class="line">    if (contains(docID) == false) &#123;</span><br><span class="line">      throw new IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int index = docID - docBase;   </span><br><span class="line">    final int offset = Math.toIntExact(offsets[index]);</span><br><span class="line">    final int length = Math.toIntExact(offsets[index + 1]) - offset;</span><br><span class="line">    final int totalLength = Math.toIntExact(offsets[chunkDocs]);</span><br><span class="line">    final int numStoredFields = Math.toIntExact(this.numStoredFields[index]);</span><br><span class="line"></span><br><span class="line">    final BytesRef bytes;</span><br><span class="line">    if (merging) &#123;</span><br><span class="line">      bytes = this.bytes;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      bytes = new BytesRef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final DataInput documentInput;</span><br><span class="line">    if (length == 0) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      fieldsStream.seek(startPointer);  // seek mmap64 偏移量获取文件</span><br><span class="line">      decompressor.decompress(fieldsStream, totalLength, offset, length, bytes); // 解压对应的数据  </span><br><span class="line">      assert bytes.length == length;</span><br><span class="line">      documentInput = new ByteArrayDataInput(bytes.bytes, bytes.offset, bytes.length);  // 将数据塞入bytes</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new SerializedDocument(documentInput, length, numStoredFields);  // 构建SerializedDocument</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面具体描述加载内容的过程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> pos = 4</span><br><span class="line">main[1] dump bytes</span><br><span class="line"> bytes = &#123;</span><br><span class="line">120, 116, 0, 26, 47, 104, 111, 109, 101, 47, 117, 98, 117, 110, 116, 117, 47, 100, 111, 99, 47, 104, 101, 108, 108, 111, 46, 116, 120, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main[1] print in</span><br><span class="line"> in = &quot;MMapIndexInput(path=&quot;/home/ubuntu/index/_j.fdt&quot;)&quot;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.LZ4WithPresetDictCompressionMode$LZ4WithPresetDictDecompressor.decompress (LZ4WithPresetDictCompressionMode.java:88)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader$BlockState.document (Lucene90CompressingStoredFieldsReader.java:595)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.document (Lucene90CompressingStoredFieldsReader.java:610)</span><br><span class="line">  [4] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.visitDocument (Lucene90CompressingStoredFieldsReader.java:628)</span><br><span class="line">  [5] org.apache.lucene.index.CodecReader.document (CodecReader.java:89)</span><br><span class="line">  [6] org.apache.lucene.index.BaseCompositeReader.document (BaseCompositeReader.java:154)</span><br><span class="line">  [7] org.apache.lucene.index.IndexReader.document (IndexReader.java:380)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.doc (IndexSearcher.java:380)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:214)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="term-文件的加载和处理"><a href="#term-文件的加载和处理" class="headerlink" title="term 文件的加载和处理"></a>term 文件的加载和处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public SegmentTermsEnum(FieldReader fr) throws IOException &#123;</span><br><span class="line">   this.fr = fr;</span><br><span class="line"></span><br><span class="line">   // if (DEBUG) &#123;</span><br><span class="line">   //   System.out.println(&quot;BTTR.init seg=&quot; + fr.parent.segment);</span><br><span class="line">   // &#125;</span><br><span class="line">   stack = new SegmentTermsEnumFrame[0];</span><br><span class="line"></span><br><span class="line">   // Used to hold seek by TermState, or cached seek</span><br><span class="line">   staticFrame = new SegmentTermsEnumFrame(this, -1);</span><br><span class="line"></span><br><span class="line">   if (fr.index == null) &#123;</span><br><span class="line">     fstReader = null;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     fstReader = fr.index.getBytesReader();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Init w/ root block; don&#x27;t use index since it may</span><br><span class="line">   // not (and need not) have been loaded</span><br><span class="line">   for (int arcIdx = 0; arcIdx &lt; arcs.length; arcIdx++) &#123;</span><br><span class="line">     arcs[arcIdx] = new FST.Arc&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   currentFrame = staticFrame;</span><br><span class="line">   final FST.Arc&lt;BytesRef&gt; arc;</span><br><span class="line">   if (fr.index != null) &#123;</span><br><span class="line">     arc = fr.index.getFirstArc(arcs[0]);</span><br><span class="line">     // Empty string prefix must have an output in the index!</span><br><span class="line">     assert arc.isFinal();</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     arc = null;</span><br><span class="line">   &#125;</span><br><span class="line">   // currentFrame = pushFrame(arc, rootCode, 0);</span><br><span class="line">   // currentFrame.loadBlock();</span><br><span class="line">   validIndexPrefix = 0;</span><br><span class="line">   // if (DEBUG) &#123;</span><br><span class="line">   //   System.out.println(&quot;init frame state &quot; + currentFrame.ord);</span><br><span class="line">   //   printSeekState();</span><br><span class="line">   // &#125;</span><br><span class="line"></span><br><span class="line">   // System.out.println();</span><br><span class="line">   // computeBlockStats().print(System.out);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>解析获取getArc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private FST.Arc&lt;BytesRef&gt; getArc(int ord) &#123;</span><br><span class="line">  if (ord &gt;= arcs.length) &#123;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class="line">    final FST.Arc&lt;BytesRef&gt;[] next =</span><br><span class="line">        new FST.Arc[ArrayUtil.oversize(1 + ord, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];</span><br><span class="line">    System.arraycopy(arcs, 0, next, 0, arcs.length);</span><br><span class="line">    for (int arcOrd = arcs.length; arcOrd &lt; next.length; arcOrd++) &#123;</span><br><span class="line">      next[arcOrd] = new FST.Arc&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    arcs = next;</span><br><span class="line">  &#125;</span><br><span class="line">  return arcs[ord];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hit: &quot;thread=main&quot;, org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.getArc(), line=222 bci=0</span><br><span class="line">222        if (ord &gt;= arcs.length) &#123;</span><br><span class="line"></span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.getArc (SegmentTermsEnum.java:222)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.seekExact (SegmentTermsEnum.java:511)</span><br><span class="line">  [3] org.apache.lucene.index.TermStates.loadTermsEnum (TermStates.java:117)</span><br><span class="line">  [4] org.apache.lucene.index.TermStates.build (TermStates.java:102)</span><br><span class="line">  [5] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="获取所有的数据"><a href="#获取所有的数据" class="headerlink" title="获取所有的数据"></a>获取所有的数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.Weight$DefaultBulkScorer.scoreAll (Weight.java:300)</span><br><span class="line">  [2] org.apache.lucene.search.Weight$DefaultBulkScorer.score (Weight.java:247)</span><br><span class="line">  [3] org.apache.lucene.search.BulkScorer.score (BulkScorer.java:38)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:770)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line">main[1] list</span><br><span class="line">296            DocIdSetIterator iterator,</span><br><span class="line">297            TwoPhaseIterator twoPhase,</span><br><span class="line">298            Bits acceptDocs)</span><br><span class="line">299            throws IOException &#123;</span><br><span class="line">300 =&gt;       if (twoPhase == null) &#123;</span><br><span class="line">301            for (int doc = iterator.nextDoc();</span><br><span class="line">302                doc != DocIdSetIterator.NO_MORE_DOCS;</span><br><span class="line">303                doc = iterator.nextDoc()) &#123;</span><br><span class="line">304              if (acceptDocs == null || acceptDocs.get(doc)) &#123;</span><br><span class="line">305                collector.collect(doc);</span><br><span class="line">main[1] print iterator</span><br><span class="line"> iterator = &quot;org.apache.lucene.search.ImpactsDISI@6279cee3&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">494        @Override</span><br><span class="line">495        public int advance(int target) throws IOException &#123;</span><br><span class="line">496          // current skip docID &lt; docIDs generated from current buffer &lt;= next skip docID</span><br><span class="line">497          // we don&#x27;t need to skip if target is buffered already</span><br><span class="line">498 =&gt;       if (docFreq &gt; BLOCK_SIZE &amp;&amp; target &gt; nextSkipDoc) &#123;</span><br><span class="line">499    </span><br><span class="line">500            if (skipper == null) &#123;</span><br><span class="line">501              // Lazy init: first time this enum has ever been used for skipping</span><br><span class="line">502              skipper =</span><br><span class="line">503                  new Lucene90SkipReader(</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.Lucene90PostingsReader$BlockDocsEnum.advance (Lucene90PostingsReader.java:498)</span><br><span class="line">  [2] org.apache.lucene.index.SlowImpactsEnum.advance (SlowImpactsEnum.java:77)</span><br><span class="line">  [3] org.apache.lucene.search.ImpactsDISI.advance (ImpactsDISI.java:135)</span><br><span class="line">  [4] org.apache.lucene.search.ImpactsDISI.nextDoc (ImpactsDISI.java:140)</span><br><span class="line">  [5] org.apache.lucene.search.Weight$DefaultBulkScorer.scoreAll (Weight.java:301)</span><br><span class="line">  [6] org.apache.lucene.search.Weight$DefaultBulkScorer.score (Weight.java:247)</span><br><span class="line">  [7] org.apache.lucene.search.BulkScorer.score (BulkScorer.java:38)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:770)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [10] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [11] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [12] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [13] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [14] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>


<p>生成iterator 的相关类 , 对应的是SegmentTermsEnum</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.TermQuery$TermWeight.getTermsEnum (TermQuery.java:145)</span><br><span class="line">  [2] org.apache.lucene.search.TermQuery$TermWeight.scorer (TermQuery.java:107)</span><br><span class="line">  [3] org.apache.lucene.search.Weight.bulkScorer (Weight.java:166)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:767)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line">main[1] print termsEnum</span><br><span class="line"> termsEnum = &quot;org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum@1a84f40f&quot;</span><br></pre></td></tr></table></figure>

<p><code>getTermsEnum</code> 方法能拿到term的统计位置偏移,SegmentTermsEnum 不包含dociterator</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.index.Term.bytes (Term.java:128)</span><br><span class="line">  [2] org.apache.lucene.search.TermQuery$TermWeight.getTermsEnum (TermQuery.java:145)</span><br><span class="line">  [3] org.apache.lucene.search.TermQuery$TermWeight.scorer (TermQuery.java:107)</span><br><span class="line">  [4] org.apache.lucene.search.Weight.bulkScorer (Weight.java:166)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:767)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">144          final TermsEnum termsEnum = context.reader().terms(term.field()).iterator();</span><br><span class="line">145 =&gt;       termsEnum.seekExact(term.bytes(), state);</span><br><span class="line">146          return termsEnum;</span><br><span class="line">147        &#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>term.bytes()</code> 就是我们的搜索值 , 所以term对应的倒排信息是从这里开始读的(还没看完,暂时那么定)</p>
<p>读出倒排信息之后,开始排序.<br>score 有iteration 可以遍历所有doc_id </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">348        // (needsFreq=false)</span><br><span class="line">349        private boolean isFreqsRead;</span><br><span class="line">350        private int singletonDocID; // docid when there is a single pulsed posting, otherwise -1</span><br><span class="line">351    </span><br><span class="line">352 =&gt;     public BlockDocsEnum(FieldInfo fieldInfo) throws IOException &#123;</span><br><span class="line">353          this.startDocIn = Lucene90PostingsReader.this.docIn;</span><br><span class="line">354          this.docIn = null;</span><br><span class="line">355          indexHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) &gt;= 0;</span><br><span class="line">356          indexHasPos =</span><br><span class="line">357              fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) &gt;= 0;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.Lucene90PostingsReader$BlockDocsEnum.&lt;init&gt; (Lucene90PostingsReader.java:352)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.Lucene90PostingsReader.postings (Lucene90PostingsReader.java:258)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.Lucene90PostingsReader.impacts (Lucene90PostingsReader.java:280)</span><br><span class="line">  [4] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.impacts (SegmentTermsEnum.java:1,150)</span><br><span class="line">  [5] org.apache.lucene.search.TermQuery$TermWeight.scorer (TermQuery.java:114)</span><br><span class="line">  [6] org.apache.lucene.search.Weight.bulkScorer (Weight.java:166)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:767)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [10] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [11] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [12] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [13] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>

<h3 id="topk-collector的堆栈"><a href="#topk-collector的堆栈" class="headerlink" title="topk collector的堆栈"></a>topk collector的堆栈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hit: &quot;thread=main&quot;, org.apache.lucene.search.TopDocsCollector.populateResults(), line=64 bci=0</span><br><span class="line">64        for (int i = howMany - 1; i &gt;= 0; i--) &#123;</span><br><span class="line"></span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.TopDocsCollector.populateResults (TopDocsCollector.java:64)</span><br><span class="line">  [2] org.apache.lucene.search.TopDocsCollector.topDocs (TopDocsCollector.java:166)</span><br><span class="line">  [3] org.apache.lucene.search.TopDocsCollector.topDocs (TopDocsCollector.java:98)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher$2.reduce (IndexSearcher.java:526)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher$2.reduce (IndexSearcher.java:505)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:694)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line">main[1]</span><br></pre></td></tr></table></figure>

<h3 id="search-过程"><a href="#search-过程" class="headerlink" title="search 过程"></a>search 过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main[1] dump collector</span><br><span class="line"> collector = &#123;</span><br><span class="line">    org.apache.lucene.search.TopScoreDocCollector.docBase: 0</span><br><span class="line">    org.apache.lucene.search.TopScoreDocCollector.pqTop: instance of org.apache.lucene.search.ScoreDoc(id=1529)</span><br><span class="line">    org.apache.lucene.search.TopScoreDocCollector.hitsThresholdChecker: instance of org.apache.lucene.search.HitsThresholdChecker$LocalHitsThresholdChecker(id=1530)</span><br><span class="line">    org.apache.lucene.search.TopScoreDocCollector.minScoreAcc: null</span><br><span class="line">    org.apache.lucene.search.TopScoreDocCollector.minCompetitiveScore: 0.0</span><br><span class="line">    org.apache.lucene.search.TopScoreDocCollector.$assertionsDisabled: true</span><br><span class="line">    org.apache.lucene.search.TopDocsCollector.EMPTY_TOPDOCS: instance of org.apache.lucene.search.TopDocs(id=1531)</span><br><span class="line">    org.apache.lucene.search.TopDocsCollector.pq: instance of org.apache.lucene.search.HitQueue(id=1532)</span><br><span class="line">    org.apache.lucene.search.TopDocsCollector.totalHits: 0</span><br><span class="line">    org.apache.lucene.search.TopDocsCollector.totalHitsRelation: instance of org.apache.lucene.search.TotalHits$Relation(id=1533)</span><br><span class="line">&#125;</span><br><span class="line">main[1] print collector</span><br><span class="line"> collector = &quot;org.apache.lucene.search.TopScoreDocCollector$SimpleTopScoreDocCollector@62bd765&quot;</span><br></pre></td></tr></table></figure>


<h3 id="获取hits-数量的过程"><a href="#获取hits-数量的过程" class="headerlink" title="获取hits 数量的过程"></a>获取hits 数量的过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">690      private &lt;C extends Collector, T&gt; T search(</span><br><span class="line">691          Weight weight, CollectorManager&lt;C, T&gt; collectorManager, C firstCollector) throws IOException &#123;</span><br><span class="line">692        if (executor == null || leafSlices.length &lt;= 1) &#123;</span><br><span class="line">693          search(leafContexts, weight, firstCollector);</span><br><span class="line">694 =&gt;       return collectorManager.reduce(Collections.singletonList(firstCollector));</span><br><span class="line">695        &#125; else &#123;</span><br><span class="line">696          final List&lt;C&gt; collectors = new ArrayList&lt;&gt;(leafSlices.length);</span><br><span class="line">697          collectors.add(firstCollector);</span><br><span class="line">698          final ScoreMode scoreMode = firstCollector.scoreMode();</span><br><span class="line">699          for (int i = 1; i &lt; leafSlices.length; ++i) &#123;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:694)</span><br><span class="line">  [2] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [3] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [5] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [6] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>

<p>在<code>org.apache.lucene.search.TopScoreDocCollector.create</code>  , 一直往上翻,发现<code>org.apache.lucene.search.IndexSearcher.searchAfter</code> 就已经有了.<br>那么这个hit数量是从哪里初始化的呢?</p>
<p>很明显,search会填充firstCollector的数据,那么是在哪里赋值的呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected void search(List&lt;LeafReaderContext&gt; leaves, Weight weight, Collector collector)</span><br><span class="line">     throws IOException &#123;</span><br><span class="line"></span><br><span class="line">   // TODO: should we make this</span><br><span class="line">   // threaded...? the Collector could be sync&#x27;d?</span><br><span class="line">   // always use single thread:</span><br><span class="line">   for (LeafReaderContext ctx : leaves) &#123; // search each subreader</span><br><span class="line">     final LeafCollector leafCollector;</span><br><span class="line">     try &#123;</span><br><span class="line">       leafCollector = collector.getLeafCollector(ctx);</span><br><span class="line">     &#125; catch (</span><br><span class="line">         @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">         CollectionTerminatedException e) &#123;</span><br><span class="line">       // there is no doc of interest in this reader context</span><br><span class="line">       // continue with the following leaf</span><br><span class="line">       continue;</span><br><span class="line">     &#125;</span><br><span class="line">     BulkScorer scorer = weight.bulkScorer(ctx);      /// 在这里会获取total hits</span><br><span class="line">     if (scorer != null) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">         scorer.score(leafCollector, ctx.reader().getLiveDocs());</span><br><span class="line">       &#125; catch (</span><br><span class="line">           @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">           CollectionTerminatedException e) &#123;</span><br><span class="line">         // collection was terminated prematurely</span><br><span class="line">         // continue with the following leaf</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>看完最后的堆栈,我们确定了totalHits 是在这里赋值的 , 也就是只要调用了一次就自增一, 很明显这是一个统计,那么这个统计就是命中的搜索内容,那么搜索内容是怎么来的呢?</p>
<p>我们只能往上追溯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.TopScoreDocCollector$SimpleTopScoreDocCollector$1.collect (TopScoreDocCollector.java:73)</span><br><span class="line">  [2] org.apache.lucene.search.Weight$DefaultBulkScorer.scoreAll (Weight.java:305)</span><br><span class="line">  [3] org.apache.lucene.search.Weight$DefaultBulkScorer.score (Weight.java:247)</span><br><span class="line">  [4] org.apache.lucene.search.BulkScorer.score (BulkScorer.java:38)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:770)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void collect(int doc) throws IOException &#123;</span><br><span class="line">          float score = scorer.score();   // 计算分数 , 也是回调专用的score 函数 , 插件化</span><br><span class="line"></span><br><span class="line">          // This collector relies on the fact that scorers produce positive values:</span><br><span class="line">          assert score &gt;= 0; // NOTE: false for NaN</span><br><span class="line"></span><br><span class="line">          totalHits++;                 // hit +1 在这里触发</span><br><span class="line">          hitsThresholdChecker.incrementHitCount();</span><br><span class="line"></span><br><span class="line">          if (minScoreAcc != null &amp;&amp; (totalHits &amp; minScoreAcc.modInterval) == 0) &#123;</span><br><span class="line">            updateGlobalMinCompetitiveScore(scorer);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (score &lt;= pqTop.score) &#123;</span><br><span class="line">            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) &#123;</span><br><span class="line">              // we just reached totalHitsThreshold, we can start setting the min</span><br><span class="line">              // competitive score now</span><br><span class="line">              updateMinCompetitiveScore(scorer);</span><br><span class="line">            &#125;</span><br><span class="line">            // Since docs are returned in-order (i.e., increasing doc Id), a document</span><br><span class="line">            // with equal score to pqTop.score cannot compete since HitQueue favors</span><br><span class="line">            // documents with lower doc Ids. Therefore reject those docs too.</span><br><span class="line">            return;</span><br><span class="line">          &#125;</span><br><span class="line">          pqTop.doc = doc + docBase;</span><br><span class="line">          pqTop.score = score;</span><br><span class="line">          pqTop = pq.updateTop();</span><br><span class="line">          updateMinCompetitiveScore(scorer);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>


<p>继续往上面推之后,我们找到了堆栈,scorer 是根据context生成的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Optional method, to return a &#123;@link BulkScorer&#125; to score the query and send hits to a &#123;@link</span><br><span class="line"> * Collector&#125;. Only queries that have a different top-level approach need to override this; the</span><br><span class="line"> * default implementation pulls a normal &#123;@link Scorer&#125; and iterates and collects the resulting</span><br><span class="line"> * hits which are not marked as deleted.</span><br><span class="line"> *</span><br><span class="line"> * @param context the &#123;@link org.apache.lucene.index.LeafReaderContext&#125; for which to return the</span><br><span class="line"> *     &#123;@link Scorer&#125;.</span><br><span class="line"> * @return a &#123;@link BulkScorer&#125; which scores documents and passes them to a collector.</span><br><span class="line"> * @throws IOException if there is a low-level I/O error</span><br><span class="line"> */</span><br><span class="line">public BulkScorer bulkScorer(LeafReaderContext context) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">  Scorer scorer = scorer(context);</span><br><span class="line">  if (scorer == null) &#123;</span><br><span class="line">    // No docs match</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // This impl always scores docs in order, so we can</span><br><span class="line">  // ignore scoreDocsInOrder:</span><br><span class="line">  return new DefaultBulkScorer(scorer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再往上看:   刚刚看到了bulkScorer 回调了一个<code>scorer</code> 方法,这个<code>scorer</code>抽象方法的实现是在<code>org.apache.lucene.search.TermQuery$TermWeight.scorer</code></p>
<p>这个scorer方法根据入参<code>context</code> 以及外部类<code>termQuery.term</code>计算htis命中的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">103          assert termStates == null || termStates.wasBuiltFor(ReaderUtil.getTopLevelContext(context))</span><br><span class="line">104              : &quot;The top-reader used to create Weight is not the same as the current reader&#x27;s top-reader (&quot;</span><br><span class="line">105                  + ReaderUtil.getTopLevelContext(context);</span><br><span class="line">106          ;</span><br><span class="line">107 =&gt;       final TermsEnum termsEnum = getTermsEnum(context);</span><br><span class="line">108          if (termsEnum == null) &#123;</span><br><span class="line">109            return null;</span><br><span class="line">110          &#125;</span><br><span class="line">111          LeafSimScorer scorer =</span><br><span class="line">112              new LeafSimScorer(simScorer, context.reader(), term.field(), scoreMode.needsScores());    // 这里term是外部类的term ,也就是this$0.term</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.TermQuery$TermWeight.scorer (TermQuery.java:107)</span><br><span class="line">  [2] org.apache.lucene.search.Weight.bulkScorer (Weight.java:166)</span><br><span class="line">  [3] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:767)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [8] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>
<p>所以之后会调用advance,最后调用的是下面这个advance方法, 这里会用到docTermStartFP , 那么这个遍历在哪里初始化? </p>
<p>其实是在termStates里面获取,初始化的地方在<code>docTermStartFP = termState.docStartFP;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">lucene\core\src\java\org\apache\lucene\codecs\lucene90\Lucene90PostingsReader.java</span><br><span class="line">    @Override</span><br><span class="line">    public int advance(int target) throws IOException &#123;</span><br><span class="line">      // current skip docID &lt; docIDs generated from current buffer &lt;= next skip docID</span><br><span class="line">      // we don&#x27;t need to skip if target is buffered already</span><br><span class="line">      if (docFreq &gt; BLOCK_SIZE &amp;&amp; target &gt; nextSkipDoc) &#123;</span><br><span class="line"></span><br><span class="line">        if (skipper == null) &#123;</span><br><span class="line">          // Lazy init: first time this enum has ever been used for skipping</span><br><span class="line">          skipper =</span><br><span class="line">              new Lucene90SkipReader(</span><br><span class="line">                  docIn.clone(), MAX_SKIP_LEVELS, indexHasPos, indexHasOffsets, indexHasPayloads);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!skipped) &#123;</span><br><span class="line">          assert skipOffset != -1;</span><br><span class="line">          // This is the first time this enum has skipped</span><br><span class="line">          // since reset() was called; load the skip data:</span><br><span class="line">          skipper.init(docTermStartFP + skipOffset, docTermStartFP, 0, 0, docFreq);</span><br><span class="line">          skipped = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // always plus one to fix the result, since skip position in Lucene90SkipReader</span><br><span class="line">        // is a little different from MultiLevelSkipListReader</span><br><span class="line">        final int newDocUpto = skipper.skipTo(target) + 1;</span><br><span class="line"></span><br><span class="line">        if (newDocUpto &gt;= blockUpto) &#123;</span><br><span class="line">          // Skipper moved</span><br><span class="line">          assert newDocUpto % BLOCK_SIZE == 0 : &quot;got &quot; + newDocUpto;</span><br><span class="line">          blockUpto = newDocUpto;</span><br><span class="line"></span><br><span class="line">          // Force to read next block</span><br><span class="line">          docBufferUpto = BLOCK_SIZE;</span><br><span class="line">          accum = skipper.getDoc(); // actually, this is just lastSkipEntry</span><br><span class="line">          docIn.seek(skipper.getDocPointer()); // now point to the block we want to search</span><br><span class="line">          // even if freqBuffer were not read from the previous block, we will mark them as read,</span><br><span class="line">          // as we don&#x27;t need to skip the previous block freqBuffer in refillDocs,</span><br><span class="line">          // as we have already positioned docIn where in needs to be.</span><br><span class="line">          isFreqsRead = true;</span><br><span class="line">        &#125;</span><br><span class="line">        // next time we call advance, this is used to</span><br><span class="line">        // foresee whether skipper is necessary.</span><br><span class="line">        nextSkipDoc = skipper.getNextSkipDoc();</span><br><span class="line">      &#125;</span><br><span class="line">      if (docBufferUpto == BLOCK_SIZE) &#123;</span><br><span class="line">        refillDocs();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Now scan... this is an inlined/pared down version</span><br><span class="line">      // of nextDoc():</span><br><span class="line">      long doc;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        doc = docBuffer[docBufferUpto];</span><br><span class="line"></span><br><span class="line">        if (doc &gt;= target) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        ++docBufferUpto;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      docBufferUpto++;</span><br><span class="line">      return this.doc = (int) doc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long cost() &#123;</span><br><span class="line">      return docFreq;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>那么我们继续看termStates是怎么初始化的? 我先猜测term会是termStates 的一个成员变量</p>
<p>通过断点,我们最后找到了下面这个:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">178      &#125;</span><br><span class="line">179    </span><br><span class="line">180      @Override</span><br><span class="line">181      public BlockTermState newTermState() &#123;</span><br><span class="line">182 =&gt;     return new IntBlockTermState();</span><br><span class="line">183      &#125;</span><br><span class="line">184    </span><br><span class="line">185      @Override</span><br><span class="line">186      public void close() throws IOException &#123;</span><br><span class="line">187        IOUtils.close(docIn, posIn, payIn);</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.Lucene90PostingsReader.newTermState (Lucene90PostingsReader.java:182)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnumFrame.&lt;init&gt; (SegmentTermsEnumFrame.java:101)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.&lt;init&gt; (SegmentTermsEnum.java:76)</span><br><span class="line">  [4] org.apache.lucene.codecs.lucene90.blocktree.FieldReader.iterator (FieldReader.java:153)</span><br><span class="line">  [5] org.apache.lucene.index.TermStates.loadTermsEnum (TermStates.java:116)</span><br><span class="line">  [6] org.apache.lucene.index.TermStates.build (TermStates.java:102)</span><br><span class="line">  [7] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [10] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [11] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [12] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [13] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line">main[1]</span><br></pre></td></tr></table></figure>


<p>最后这里应该就是最最核心的获取词的流程了,i hope so</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">113    </span><br><span class="line">114      private static TermsEnum loadTermsEnum(LeafReaderContext ctx, Term term) throws IOException &#123;</span><br><span class="line">115        final Terms terms = Terms.getTerms(ctx.reader(), term.field());</span><br><span class="line">116        final TermsEnum termsEnum = terms.iterator();</span><br><span class="line">117 =&gt;     if (termsEnum.seekExact(term.bytes())) &#123;</span><br><span class="line">118          return termsEnum;</span><br><span class="line">119        &#125;</span><br><span class="line">120        return null;</span><br><span class="line">121      &#125;</span><br><span class="line">122    </span><br><span class="line">main[1] print term.bytes()</span><br><span class="line"> term.bytes() = &quot;[61 6d]&quot;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.index.TermStates.loadTermsEnum (TermStates.java:117)</span><br><span class="line">  [2] org.apache.lucene.index.TermStates.build (TermStates.java:102)</span><br><span class="line">  [3] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [8] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>


<p>最后的最后应该是调用这里: 获取所有的term的个数,具体是哪里还需要判断,但是路径应该就是这里了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line">// Target&#x27;s prefix matches this block&#x27;s prefix; we</span><br><span class="line">// scan the entries check if the suffix matches.</span><br><span class="line">public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">  // if (DEBUG) System.out.println(&quot;    scanToTermLeaf: block fp=&quot; + fp + &quot; prefix=&quot; + prefix + &quot;</span><br><span class="line">  // nextEnt=&quot; + nextEnt + &quot; (of &quot; + entCount + &quot;) target=&quot; + brToString(target) + &quot; term=&quot; +</span><br><span class="line">  // brToString(term));</span><br><span class="line"></span><br><span class="line">  assert nextEnt != -1;</span><br><span class="line"></span><br><span class="line">  ste.termExists = true;</span><br><span class="line">  subCode = 0;</span><br><span class="line"></span><br><span class="line">  if (nextEnt == entCount) &#123;</span><br><span class="line">    if (exactOnly) &#123;</span><br><span class="line">      fillTerm();</span><br><span class="line">    &#125;</span><br><span class="line">    return SeekStatus.END;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert prefixMatches(target);</span><br><span class="line"></span><br><span class="line">  // TODO: binary search when all terms have the same length, which is common for ID fields,</span><br><span class="line">  // which are also the most sensitive to lookup performance?</span><br><span class="line">  // Loop over each entry (term or sub-block) in this block:</span><br><span class="line">  do &#123;</span><br><span class="line">    nextEnt++;</span><br><span class="line"></span><br><span class="line">    suffix = suffixLengthsReader.readVInt();</span><br><span class="line"></span><br><span class="line">    // if (DEBUG) &#123;</span><br><span class="line">    //   BytesRef suffixBytesRef = new BytesRef();</span><br><span class="line">    //   suffixBytesRef.bytes = suffixBytes;</span><br><span class="line">    //   suffixBytesRef.offset = suffixesReader.getPosition();</span><br><span class="line">    //   suffixBytesRef.length = suffix;</span><br><span class="line">    //   System.out.println(&quot;      cycle: term &quot; + (nextEnt-1) + &quot; (of &quot; + entCount + &quot;) suffix=&quot;</span><br><span class="line">    // + brToString(suffixBytesRef));</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    startBytePos = suffixesReader.getPosition();</span><br><span class="line">    suffixesReader.skipBytes(suffix);</span><br><span class="line"></span><br><span class="line">    // Loop over bytes in the suffix, comparing to the target</span><br><span class="line">    final int cmp =</span><br><span class="line">        Arrays.compareUnsigned(</span><br><span class="line">            suffixBytes,</span><br><span class="line">            startBytePos,</span><br><span class="line">            startBytePos + suffix,</span><br><span class="line">            target.bytes,</span><br><span class="line">            target.offset + prefix,</span><br><span class="line">            target.offset + target.length);</span><br><span class="line"></span><br><span class="line">    if (cmp &lt; 0) &#123;</span><br><span class="line">      // Current entry is still before the target;</span><br><span class="line">      // keep scanning</span><br><span class="line">    &#125; else if (cmp &gt; 0) &#123;</span><br><span class="line">      // Done!  Current entry is after target --</span><br><span class="line">      // return NOT_FOUND:</span><br><span class="line">      fillTerm();</span><br><span class="line"></span><br><span class="line">      // if (DEBUG) System.out.println(&quot;        not found&quot;);</span><br><span class="line">      return SeekStatus.NOT_FOUND;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Exact match!</span><br><span class="line"></span><br><span class="line">      // This cannot be a sub-block because we</span><br><span class="line">      // would have followed the index to this</span><br><span class="line">      // sub-block from the start:</span><br><span class="line"></span><br><span class="line">      assert ste.termExists;</span><br><span class="line">      fillTerm();</span><br><span class="line">      // if (DEBUG) System.out.println(&quot;        found!&quot;);</span><br><span class="line">      return SeekStatus.FOUND;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; while (nextEnt &lt; entCount);</span><br><span class="line"></span><br><span class="line">  // It is possible (and OK) that terms index pointed us</span><br><span class="line">  // at this block, but, we scanned the entire block and</span><br><span class="line">  // did not find the term to position to.  This happens</span><br><span class="line">  // when the target is after the last term in the block</span><br><span class="line">  // (but, before the next term in the index).  EG</span><br><span class="line">  // target could be foozzz, and terms index pointed us</span><br><span class="line">  // to the foo* block, but the last term in this block</span><br><span class="line">  // was fooz (and, eg, first term in the next block will</span><br><span class="line">  // bee fop).</span><br><span class="line">  // if (DEBUG) System.out.println(&quot;      block end&quot;);</span><br><span class="line">  if (exactOnly) &#123;</span><br><span class="line">    fillTerm();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // TODO: not consistent that in the</span><br><span class="line">  // not-exact case we don&#x27;t next() into the next</span><br><span class="line">  // frame here</span><br><span class="line">  return SeekStatus.END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Target&#x27;s prefix matches this block&#x27;s prefix; we</span><br><span class="line">// scan the entries check if the suffix matches.</span><br><span class="line">public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">  // if (DEBUG) System.out.println(&quot;    scanToTermNonLeaf: block fp=&quot; + fp + &quot; prefix=&quot; + prefix +</span><br><span class="line">  // &quot; nextEnt=&quot; + nextEnt + &quot; (of &quot; + entCount + &quot;) target=&quot; + brToString(target) + &quot; term=&quot; +</span><br><span class="line">  // brToString(target));</span><br><span class="line"></span><br><span class="line">  assert nextEnt != -1;</span><br><span class="line"></span><br><span class="line">  if (nextEnt == entCount) &#123;</span><br><span class="line">    if (exactOnly) &#123;</span><br><span class="line">      fillTerm();</span><br><span class="line">      ste.termExists = subCode == 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return SeekStatus.END;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert prefixMatches(target);</span><br><span class="line"></span><br><span class="line">  // Loop over each entry (term or sub-block) in this block:</span><br><span class="line">  while (nextEnt &lt; entCount) &#123;</span><br><span class="line"></span><br><span class="line">    nextEnt++;</span><br><span class="line"></span><br><span class="line">    final int code = suffixLengthsReader.readVInt();</span><br><span class="line">    suffix = code &gt;&gt;&gt; 1;</span><br><span class="line"></span><br><span class="line">    // if (DEBUG) &#123;</span><br><span class="line">    //  BytesRef suffixBytesRef = new BytesRef();</span><br><span class="line">    //  suffixBytesRef.bytes = suffixBytes;</span><br><span class="line">    //  suffixBytesRef.offset = suffixesReader.getPosition();</span><br><span class="line">    //  suffixBytesRef.length = suffix;</span><br><span class="line">    //  System.out.println(&quot;      cycle: &quot; + ((code&amp;1)==1 ? &quot;sub-block&quot; : &quot;term&quot;) + &quot; &quot; +</span><br><span class="line">    // (nextEnt-1) + &quot; (of &quot; + entCount + &quot;) suffix=&quot; + brToString(suffixBytesRef));</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    final int termLen = prefix + suffix;</span><br><span class="line">    startBytePos = suffixesReader.getPosition();</span><br><span class="line">    suffixesReader.skipBytes(suffix);</span><br><span class="line">    ste.termExists = (code &amp; 1) == 0;</span><br><span class="line">    if (ste.termExists) &#123;</span><br><span class="line">      state.termBlockOrd++;</span><br><span class="line">      subCode = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      subCode = suffixLengthsReader.readVLong();</span><br><span class="line">      lastSubFP = fp - subCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int cmp =</span><br><span class="line">        Arrays.compareUnsigned(</span><br><span class="line">            suffixBytes,</span><br><span class="line">            startBytePos,</span><br><span class="line">            startBytePos + suffix,</span><br><span class="line">            target.bytes,</span><br><span class="line">            target.offset + prefix,</span><br><span class="line">            target.offset + target.length);</span><br><span class="line"></span><br><span class="line">    if (cmp &lt; 0) &#123;</span><br><span class="line">      // Current entry is still before the target;</span><br><span class="line">      // keep scanning</span><br><span class="line">    &#125; else if (cmp &gt; 0) &#123;</span><br><span class="line">      // Done!  Current entry is after target --</span><br><span class="line">      // return NOT_FOUND:</span><br><span class="line">      fillTerm();</span><br><span class="line"></span><br><span class="line">      // if (DEBUG) System.out.println(&quot;        maybe done exactOnly=&quot; + exactOnly + &quot;</span><br><span class="line">      // ste.termExists=&quot; + ste.termExists);</span><br><span class="line"></span><br><span class="line">      if (!exactOnly &amp;&amp; !ste.termExists) &#123;</span><br><span class="line">        // System.out.println(&quot;  now pushFrame&quot;);</span><br><span class="line">        // TODO this</span><br><span class="line">        // We are on a sub-block, and caller wants</span><br><span class="line">        // us to position to the next term after</span><br><span class="line">        // the target, so we must recurse into the</span><br><span class="line">        // sub-frame(s):</span><br><span class="line">        ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);</span><br><span class="line">        ste.currentFrame.loadBlock();</span><br><span class="line">        while (ste.currentFrame.next()) &#123;</span><br><span class="line">          ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length());</span><br><span class="line">          ste.currentFrame.loadBlock();         /////////////////////////////////////////////////// 这里会有流的加载</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // if (DEBUG) System.out.println(&quot;        not found&quot;);</span><br><span class="line">      return SeekStatus.NOT_FOUND;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Exact match!</span><br><span class="line"></span><br><span class="line">      // This cannot be a sub-block because we</span><br><span class="line">      // would have followed the index to this</span><br><span class="line">      // sub-block from the start:</span><br><span class="line"></span><br><span class="line">      assert ste.termExists;</span><br><span class="line">      fillTerm();</span><br><span class="line">      // if (DEBUG) System.out.println(&quot;        found!&quot;);</span><br><span class="line">      return SeekStatus.FOUND;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // It is possible (and OK) that terms index pointed us</span><br><span class="line">  // at this block, but, we scanned the entire block and</span><br><span class="line">  // did not find the term to position to.  This happens</span><br><span class="line">  // when the target is after the last term in the block</span><br><span class="line">  // (but, before the next term in the index).  EG</span><br><span class="line">  // target could be foozzz, and terms index pointed us</span><br><span class="line">  // to the foo* block, but the last term in this block</span><br><span class="line">  // was fooz (and, eg, first term in the next block will</span><br><span class="line">  // bee fop).</span><br><span class="line">  // if (DEBUG) System.out.println(&quot;      block end&quot;);</span><br><span class="line">  if (exactOnly) &#123;</span><br><span class="line">    fillTerm();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // TODO: not consistent that in the</span><br><span class="line">  // not-exact case we don&#x27;t next() into the next</span><br><span class="line">  // frame here</span><br><span class="line">  return SeekStatus.END;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>termState 是如何被反序列化的?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hit: &quot;thread=main&quot;, org.apache.lucene.codecs.lucene90.Lucene90PostingsReader.decodeTerm(), line=194 bci=0</span><br><span class="line">194        final IntBlockTermState termState = (IntBlockTermState) _termState;</span><br><span class="line"></span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.Lucene90PostingsReader.decodeTerm (Lucene90PostingsReader.java:194)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnumFrame.decodeMetaData (SegmentTermsEnumFrame.java:476)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.termState (SegmentTermsEnum.java:1,178)</span><br><span class="line">  [4] org.apache.lucene.index.TermStates.build (TermStates.java:104)</span><br><span class="line">  [5] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">  public void decodeTerm(</span><br><span class="line">      DataInput in, FieldInfo fieldInfo, BlockTermState _termState, boolean absolute)</span><br><span class="line">      throws IOException &#123;</span><br><span class="line">    final IntBlockTermState termState = (IntBlockTermState) _termState;</span><br><span class="line">    final boolean fieldHasPositions =</span><br><span class="line">        fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) &gt;= 0;</span><br><span class="line">    final boolean fieldHasOffsets =</span><br><span class="line">        fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)</span><br><span class="line">            &gt;= 0;</span><br><span class="line">    final boolean fieldHasPayloads = fieldInfo.hasPayloads();</span><br><span class="line"></span><br><span class="line">    if (absolute) &#123;</span><br><span class="line">      termState.docStartFP = 0;</span><br><span class="line">      termState.posStartFP = 0;</span><br><span class="line">      termState.payStartFP = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final long l = in.readVLong();</span><br><span class="line">    if ((l &amp; 0x01) == 0) &#123;</span><br><span class="line">      termState.docStartFP += l &gt;&gt;&gt; 1;</span><br><span class="line">      if (termState.docFreq == 1) &#123;</span><br><span class="line">        termState.singletonDocID = in.readVInt();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        termState.singletonDocID = -1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      assert absolute == false;</span><br><span class="line">      assert termState.singletonDocID != -1;</span><br><span class="line">      termState.singletonDocID += BitUtil.zigZagDecode(l &gt;&gt;&gt; 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fieldHasPositions) &#123;</span><br><span class="line">      termState.posStartFP += in.readVLong();</span><br><span class="line">      if (fieldHasOffsets || fieldHasPayloads) &#123;</span><br><span class="line">        termState.payStartFP += in.readVLong();</span><br><span class="line">      &#125;</span><br><span class="line">      if (termState.totalTermFreq &gt; BLOCK_SIZE) &#123;</span><br><span class="line">        termState.lastPosBlockOffset = in.readVLong();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        termState.lastPosBlockOffset = -1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (termState.docFreq &gt; BLOCK_SIZE) &#123;</span><br><span class="line">      termState.skipOffset = in.readVLong();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      termState.skipOffset = -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其实ste持有term的引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main[2] dump ste.term.ref.bytes</span><br><span class="line"> ste.term.ref.bytes = &#123;</span><br><span class="line">97, 109, 0, 0, 0, 0, 0, 0</span><br><span class="line">&#125;</span><br><span class="line">main[2] where</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnumFrame.decodeMetaData (SegmentTermsEnumFrame.java:476)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.termState (SegmentTermsEnum.java:1,178)</span><br><span class="line">  [4] org.apache.lucene.index.TermStates.build (TermStates.java:104)</span><br><span class="line">  [5] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>

<p>ste.in 描述的是读取的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> ste.in = &#123;</span><br><span class="line">    $assertionsDisabled: true</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.EMPTY_FLOATBUFFER: instance of java.nio.HeapFloatBuffer(id=1473)</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.EMPTY_LONGBUFFER: instance of java.nio.HeapLongBuffer(id=1474)</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.EMPTY_INTBUFFER: instance of java.nio.HeapIntBuffer(id=1475)</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.length: 1993</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.chunkSizeMask: 1073741823</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.chunkSizePower: 30</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.guard: instance of org.apache.lucene.store.ByteBufferGuard(id=1476)</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.buffers: instance of java.nio.ByteBuffer[1] (id=1477)</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.curBufIndex: 0</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.curBuf: instance of java.nio.DirectByteBufferR(id=1479)</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.curLongBufferViews: null</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.curIntBufferViews: null</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.curFloatBufferViews: null</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.isClone: true</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.$assertionsDisabled: true</span><br><span class="line">    org.apache.lucene.store.IndexInput.resourceDescription: &quot;MMapIndexInput(path=&quot;/home/dai/index/_7.cfs&quot;) [slice=_7_Lucene90_0.tim]&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.amazingkoala.com.cn/Lucene/Search/2020/0812/161.html">相关阅读</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public void nextLeaf() &#123;</span><br><span class="line">  // if (DEBUG) System.out.println(&quot;  frame.next ord=&quot; + ord + &quot; nextEnt=&quot; + nextEnt + &quot;</span><br><span class="line">  // entCount=&quot; + entCount);</span><br><span class="line">  assert nextEnt != -1 &amp;&amp; nextEnt &lt; entCount</span><br><span class="line">      : &quot;nextEnt=&quot; + nextEnt + &quot; entCount=&quot; + entCount + &quot; fp=&quot; + fp;</span><br><span class="line">  nextEnt++;</span><br><span class="line">  suffix = suffixLengthsReader.readVInt();</span><br><span class="line">  startBytePos = suffixesReader.getPosition();</span><br><span class="line">  ste.term.setLength(prefix + suffix);</span><br><span class="line">  ste.term.grow(ste.term.length());</span><br><span class="line">  suffixesReader.readBytes(ste.term.bytes(), prefix, suffix);</span><br><span class="line">  ste.termExists = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean nextNonLeaf() throws IOException &#123;</span><br><span class="line">  // if (DEBUG) System.out.println(&quot;  stef.next ord=&quot; + ord + &quot; nextEnt=&quot; + nextEnt + &quot; entCount=&quot;</span><br><span class="line">  // + entCount + &quot; fp=&quot; + suffixesReader.getPosition());</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (nextEnt == entCount) &#123;</span><br><span class="line">      assert arc == null || (isFloor &amp;&amp; isLastInFloor == false)</span><br><span class="line">          : &quot;isFloor=&quot; + isFloor + &quot; isLastInFloor=&quot; + isLastInFloor;</span><br><span class="line">      loadNextFloorBlock();</span><br><span class="line">      if (isLeafBlock) &#123;</span><br><span class="line">        nextLeaf();</span><br><span class="line">        return false;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert nextEnt != -1 &amp;&amp; nextEnt &lt; entCount</span><br><span class="line">        : &quot;nextEnt=&quot; + nextEnt + &quot; entCount=&quot; + entCount + &quot; fp=&quot; + fp;</span><br><span class="line">    nextEnt++;</span><br><span class="line">    final int code = suffixLengthsReader.readVInt();</span><br><span class="line">    suffix = code &gt;&gt;&gt; 1;</span><br><span class="line">    startBytePos = suffixesReader.getPosition();</span><br><span class="line">    ste.term.setLength(prefix + suffix);</span><br><span class="line">    ste.term.grow(ste.term.length());</span><br><span class="line">    suffixesReader.readBytes(ste.term.bytes(), prefix, suffix);   // 这里是最核心的地方吗?</span><br><span class="line">    if ((code &amp; 1) == 0) &#123;</span><br><span class="line">      // A normal term</span><br><span class="line">      ste.termExists = true;</span><br><span class="line">      subCode = 0;</span><br><span class="line">      state.termBlockOrd++;</span><br><span class="line">      return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // A sub-block; make sub-FP absolute:</span><br><span class="line">      ste.termExists = false;</span><br><span class="line">      subCode = suffixLengthsReader.readVLong();</span><br><span class="line">      lastSubFP = fp - subCode;</span><br><span class="line">      // if (DEBUG) &#123;</span><br><span class="line">      // System.out.println(&quot;    lastSubFP=&quot; + lastSubFP);</span><br><span class="line">      // &#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>看上去这就行读取term 在文件中的位置信息:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnumFrame.scanToTermLeaf (SegmentTermsEnumFrame.java:593)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnumFrame.scanToTerm (SegmentTermsEnumFrame.java:530)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.seekExact (SegmentTermsEnum.java:538)</span><br><span class="line">  [4] org.apache.lucene.index.TermStates.loadTermsEnum (TermStates.java:117)</span><br><span class="line">  [5] org.apache.lucene.index.TermStates.build (TermStates.java:102)</span><br><span class="line">  [6] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [10] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [12] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line">main[1] dump suffixBytes</span><br><span class="line"> suffixBytes = &#123;</span><br><span class="line">97, 109, 97, 110, 100, 98, 117, 116, 99, 97, 110, 100, 111, 104, 101, 108, 108, 111, 104, 105, 105, 105, 115, 105, 116, 107, 110, 111, 119, 109, 97, 121, 109, 111, 110, 103, 111, 110, 111, 116, 116, 114, 121, 119, 104, 97, 116, 119, 111, 114, 108, 100, 121, 111, 117, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="term-对应docfreq-的统计信息的读取位置"><a href="#term-对应docfreq-的统计信息的读取位置" class="headerlink" title="term 对应docfreq 的统计信息的读取位置"></a>term 对应docfreq 的统计信息的读取位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">451          // postings</span><br><span class="line">452    </span><br><span class="line">453          // TODO: if docFreq were bulk decoded we could</span><br><span class="line">454          // just skipN here:</span><br><span class="line">455 =&gt;       if (statsSingletonRunLength &gt; 0) &#123;</span><br><span class="line">456            state.docFreq = 1;</span><br><span class="line">457            state.totalTermFreq = 1;</span><br><span class="line">458            statsSingletonRunLength--;</span><br><span class="line">459          &#125; else &#123;</span><br><span class="line">460            int token = statsReader.readVInt();</span><br><span class="line">main[1] print statsSingletonRunLength</span><br><span class="line"> statsSingletonRunLength = 0</span><br><span class="line">main[1] next</span><br><span class="line">&gt; </span><br><span class="line">Step completed: &quot;thread=main&quot;, org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnumFrame.decodeMetaData(), line=460 bci=80</span><br><span class="line">460            int token = statsReader.readVInt();</span><br><span class="line"></span><br><span class="line">main[1] list</span><br><span class="line">456            state.docFreq = 1;</span><br><span class="line">457            state.totalTermFreq = 1;</span><br><span class="line">458            statsSingletonRunLength--;</span><br><span class="line">459          &#125; else &#123;</span><br><span class="line">460 =&gt;         int token = statsReader.readVInt();</span><br><span class="line">461            if ((token &amp; 1) == 1) &#123;</span><br><span class="line">462              state.docFreq = 1;</span><br><span class="line">463              state.totalTermFreq = 1;</span><br><span class="line">464              statsSingletonRunLength = token &gt;&gt;&gt; 1;</span><br><span class="line">465            &#125; else &#123;</span><br><span class="line">main[1] print statsReader</span><br><span class="line"> statsReader = &quot;org.apache.lucene.store.ByteArrayDataInput@6b67034&quot;</span><br><span class="line">main[1] dump statsReader</span><br><span class="line"> statsReader = &#123;</span><br><span class="line">    bytes: instance of byte[64] (id=1520)</span><br><span class="line">    pos: 0</span><br><span class="line">    limit: 16</span><br><span class="line">&#125;</span><br><span class="line">main[1] dump statsReader.bytes</span><br><span class="line"> statsReader.bytes = &#123;</span><br><span class="line">4, 0, 9, 2, 1, 4, 0, 3, 2, 1, 1, 2, 1, 7, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>搜索的<code>term</code> 是<code>am</code>对应的是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">00000000  3f d7 6c 17 12 42 6c 6f  63 6b 54 72 65 65 54 65  |?.l..BlockTreeTe|</span><br><span class="line">00000010  72 6d 73 44 69 63 74 00  00 00 00 fe ea 80 e6 45  |rmsDict........E|</span><br><span class="line">00000020  20 d8 56 64 1b 1b 1b 89  70 fe 67 0a 4c 75 63 65  | .Vd....p.g.Luce|</span><br><span class="line">00000030  6e 65 39 30 5f 30 25 bc  03 61 6d 61 6e 64 62 75  |ne90_0%..amandbu|</span><br><span class="line">00000040  74 63 61 6e 64 6f 68 65  6c 6c 6f 68 69 69 69 73  |tcandohellohiiis|</span><br><span class="line">00000050  69 74 6b 6e 6f 77 6d 61  79 6d 6f 6e 67 6f 6e 6f  |itknowmaymongono|</span><br><span class="line">00000060  74 74 72 79 77 68 61 74  77 6f 72 6c 64 79 6f 75  |ttrywhatworldyou|</span><br><span class="line">00000070  24 02 03 03 03 02 05 02  01 02 02 04 03 05 03 03  |$...............|</span><br><span class="line">00000080  04 05 03 10 04 00 09 02  01 04 00 03 02 01 01 02  |................|   &lt;----  在这一行第四个开始的序列</span><br><span class="line">00000090  01 07 02 02 26 7a 3d 04  01 02 03 01 01 01 01 01  |....&amp;z=.........|</span><br><span class="line">000000a0  05 01 01 01 00 02 04 00  02 01 01 01 01 01 02 01  |................|</span><br><span class="line">000000b0  01 01 02 01 01 01 01 05  01 03 01 05 a4 03 2f 68  |............../h|</span><br><span class="line">000000c0  6f 6d 65 2f 75 62 75 6e  74 75 2f 64 6f 63 2f 68  |ome/ubuntu/doc/h|</span><br><span class="line">000000d0  65 6c 6c 6f 2e 74 78 74  2f 68 6f 6d 65 2f 75 62  |ello.txt/home/ub|</span><br><span class="line">000000e0  75 6e 74 75 2f 64 6f 63  2f 6d 6f 6e 67 6f 2e 74  |untu/doc/mongo.t|</span><br><span class="line">000000f0  78 74 05 1a 01 03 04 82  01 01 03 c0 28 93 e8 00  |xt..........(...|</span><br><span class="line">00000100  00 00 00 00 00 00 00 da  02 a3 a3                 |...........|</span><br></pre></td></tr></table></figure>


<p>那么docFreq 的赋值在哪里呢? </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> currentFrame.state.docFreq = 2</span><br><span class="line">main[1] list</span><br><span class="line">1,113        assert !eof;</span><br><span class="line">1,114        // if (DEBUG) System.out.println(&quot;BTR.docFreq&quot;);</span><br><span class="line">1,115        currentFrame.decodeMetaData();</span><br><span class="line">1,116        // if (DEBUG) System.out.println(&quot;  return &quot; + currentFrame.state.docFreq);</span><br><span class="line">1,117 =&gt;     return currentFrame.state.docFreq;</span><br><span class="line">1,118      &#125;</span><br><span class="line">1,119    </span><br><span class="line">1,120      @Override</span><br><span class="line">1,121      public long totalTermFreq() throws IOException &#123;</span><br><span class="line">1,122        assert !eof;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.docFreq (SegmentTermsEnum.java:1,117)</span><br><span class="line">  [2] org.apache.lucene.index.TermStates.build (TermStates.java:107)</span><br><span class="line">  [3] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [8] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>

<p>读取的过程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">readByte:110, ByteBufferIndexInput (org.apache.lucene.store)</span><br><span class="line">readVInt:121, DataInput (org.apache.lucene.store)</span><br><span class="line">readVIntBlock:149, Lucene90PostingsReader (org.apache.lucene.codecs.lucene90)</span><br><span class="line">refillDocs:472, Lucene90PostingsReader$BlockDocsEnum (org.apache.lucene.codecs.lucene90)</span><br><span class="line">advance:538, Lucene90PostingsReader$BlockDocsEnum (org.apache.lucene.codecs.lucene90)</span><br><span class="line">advance:77, SlowImpactsEnum (org.apache.lucene.index)</span><br><span class="line">advance:128, ImpactsDISI (org.apache.lucene.search)</span><br><span class="line">nextDoc:133, ImpactsDISI (org.apache.lucene.search)</span><br><span class="line">scoreAll:301, Weight$DefaultBulkScorer (org.apache.lucene.search)</span><br><span class="line">score:247, Weight$DefaultBulkScorer (org.apache.lucene.search)</span><br><span class="line">score:38, BulkScorer (org.apache.lucene.search)</span><br><span class="line">search:776, IndexSearcher (org.apache.lucene.search)</span><br><span class="line">search:694, IndexSearcher (org.apache.lucene.search)</span><br><span class="line">search:688, IndexSearcher (org.apache.lucene.search)</span><br><span class="line">searchAfter:523, IndexSearcher (org.apache.lucene.search)</span><br><span class="line">search:538, IndexSearcher (org.apache.lucene.search)</span><br><span class="line">doPagingSearch:161, SearchFiles (com.dinosaur.lucene.skiptest)</span><br><span class="line">queryTest:52, QueryTest (com.dinosaur.lucene.demo)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="tim-文件在哪里初始化"><a href="#tim-文件在哪里初始化" class="headerlink" title="tim 文件在哪里初始化"></a>tim 文件在哪里初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">void loadBlock() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">  // Clone the IndexInput lazily, so that consumers</span><br><span class="line">  // that just pull a TermsEnum to</span><br><span class="line">  // seekExact(TermState) don&#x27;t pay this cost:</span><br><span class="line">  ste.initIndexInput();</span><br><span class="line"></span><br><span class="line">  if (nextEnt != -1) &#123;</span><br><span class="line">    // Already loaded</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // System.out.println(&quot;blc=&quot; + blockLoadCount);</span><br><span class="line"></span><br><span class="line">  ste.in.seek(fp);</span><br><span class="line">  int code = ste.in.readVInt();</span><br><span class="line">  entCount = code &gt;&gt;&gt; 1;</span><br><span class="line">  assert entCount &gt; 0;</span><br><span class="line">  isLastInFloor = (code &amp; 1) != 0;</span><br><span class="line"></span><br><span class="line">  assert arc == null || (isLastInFloor || isFloor)</span><br><span class="line">      : &quot;fp=&quot; + fp + &quot; arc=&quot; + arc + &quot; isFloor=&quot; + isFloor + &quot; isLastInFloor=&quot; + isLastInFloor;</span><br><span class="line"></span><br><span class="line">  // TODO: if suffixes were stored in random-access</span><br><span class="line">  // array structure, then we could do binary search</span><br><span class="line">  // instead of linear scan to find target term; eg</span><br><span class="line">  // we could have simple array of offsets</span><br><span class="line"></span><br><span class="line">  final long startSuffixFP = ste.in.getFilePointer();</span><br><span class="line">  // term suffixes:</span><br><span class="line">  final long codeL = ste.in.readVLong();</span><br><span class="line">  isLeafBlock = (codeL &amp; 0x04) != 0;</span><br><span class="line">  final int numSuffixBytes = (int) (codeL &gt;&gt;&gt; 3);</span><br><span class="line">  if (suffixBytes.length &lt; numSuffixBytes) &#123;</span><br><span class="line">    suffixBytes = new byte[ArrayUtil.oversize(numSuffixBytes, 1)];</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    compressionAlg = CompressionAlgorithm.byCode((int) codeL &amp; 0x03);</span><br><span class="line">  &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">    throw new CorruptIndexException(e.getMessage(), ste.in, e);</span><br><span class="line">  &#125;</span><br><span class="line">  compressionAlg.read(ste.in, suffixBytes, numSuffixBytes);</span><br><span class="line">  suffixesReader.reset(suffixBytes, 0, numSuffixBytes);</span><br><span class="line"></span><br><span class="line">  int numSuffixLengthBytes = ste.in.readVInt();</span><br><span class="line">  final boolean allEqual = (numSuffixLengthBytes &amp; 0x01) != 0;</span><br><span class="line">  numSuffixLengthBytes &gt;&gt;&gt;= 1;</span><br><span class="line">  if (suffixLengthBytes.length &lt; numSuffixLengthBytes) &#123;</span><br><span class="line">    suffixLengthBytes = new byte[ArrayUtil.oversize(numSuffixLengthBytes, 1)];</span><br><span class="line">  &#125;</span><br><span class="line">  if (allEqual) &#123;</span><br><span class="line">    Arrays.fill(suffixLengthBytes, 0, numSuffixLengthBytes, ste.in.readByte());</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ste.in.readBytes(suffixLengthBytes, 0, numSuffixLengthBytes);</span><br><span class="line">  &#125;</span><br><span class="line">  suffixLengthsReader.reset(suffixLengthBytes, 0, numSuffixLengthBytes);</span><br><span class="line">  totalSuffixBytes = ste.in.getFilePointer() - startSuffixFP;</span><br><span class="line"></span><br><span class="line">  /*if (DEBUG) &#123;</span><br><span class="line">  if (arc == null) &#123;</span><br><span class="line">  System.out.println(&quot;    loadBlock (next) fp=&quot; + fp + &quot; entCount=&quot; + entCount + &quot; prefixLen=&quot; + prefix + &quot; isLastInFloor=&quot; + isLastInFloor + &quot; leaf?=&quot; + isLeafBlock);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  System.out.println(&quot;    loadBlock (seek) fp=&quot; + fp + &quot; entCount=&quot; + entCount + &quot; prefixLen=&quot; + prefix + &quot; hasTerms?=&quot; + hasTerms + &quot; isFloor?=&quot; + isFloor + &quot; isLastInFloor=&quot; + isLastInFloor + &quot; leaf?=&quot; + isLeafBlock);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;*/</span><br><span class="line"></span><br><span class="line">  // stats</span><br><span class="line">  int numBytes = ste.in.readVInt();</span><br><span class="line">  if (statBytes.length &lt; numBytes) &#123;</span><br><span class="line">    statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];</span><br><span class="line">  &#125;</span><br><span class="line">  ste.in.readBytes(statBytes, 0, numBytes);</span><br><span class="line">  statsReader.reset(statBytes, 0, numBytes);</span><br><span class="line">  statsSingletonRunLength = 0;</span><br><span class="line">  metaDataUpto = 0;</span><br><span class="line"></span><br><span class="line">  state.termBlockOrd = 0;</span><br><span class="line">  nextEnt = 0;</span><br><span class="line">  lastSubFP = -1;</span><br><span class="line"></span><br><span class="line">  // TODO: we could skip this if !hasTerms; but</span><br><span class="line">  // that&#x27;s rare so won&#x27;t help much</span><br><span class="line">  // metadata</span><br><span class="line">  numBytes = ste.in.readVInt();</span><br><span class="line">  if (bytes.length &lt; numBytes) &#123;</span><br><span class="line">    bytes = new byte[ArrayUtil.oversize(numBytes, 1)];</span><br><span class="line">  &#125;</span><br><span class="line">  ste.in.readBytes(bytes, 0, numBytes);</span><br><span class="line">  bytesReader.reset(bytes, 0, numBytes);</span><br><span class="line"></span><br><span class="line">  // Sub-blocks of a single floor block are always</span><br><span class="line">  // written one after another -- tail recurse:</span><br><span class="line">  fpEnd = ste.in.getFilePointer();</span><br><span class="line">  // if (DEBUG) &#123;</span><br><span class="line">  //   System.out.println(&quot;      fpEnd=&quot; + fpEnd);</span><br><span class="line">  // &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我们知道Lucene将索引文件拆分为了多个文件，这里我们仅讨论倒排索引部分。</span><br><span class="line"></span><br><span class="line">Lucene把用于存储Term的索引文件叫Terms Index，它的后缀是.tip；把Postings信息分别存储在.doc、.pay、.pox，分别记录Postings的DocId信息和Term的词频、Payload信息、pox是记录位置信息。Terms Dictionary的文件后缀称为.tim，它是Term与Postings的关系纽带，存储了Term和其对应的Postings文件指针。</span><br><span class="line"></span><br><span class="line">总体来说，通过Terms Index(.tip)能够快速地在Terms Dictionary(.tim)中找到你的想要的Term，以及它对应的Postings文件指针与Term在Segment作用域上的统计信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">postings: 实际上Postings包含的东西并不仅仅是DocIDs（我们通常把这一个有序文档编号系列叫DocIDs），它还包括文档编号、以及词频、Term在文档中的位置信息、还有Payload数据。</span><br><span class="line"></span><br><span class="line">所以关于倒排索引至少涉及5类文件，本文不会全面展开。</span><br></pre></td></tr></table></figure>




<p>相关阅读</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://lucene.apache.org/core/3_0_3/fileformats.html">https://lucene.apache.org/core/3_0_3/fileformats.html</a></li>
<li><a target="_blank" rel="noopener" href="https://lucene.apache.org/core/2_9_4/scoring.html">https://lucene.apache.org/core/2_9_4/scoring.html</a></li>
<li><a target="_blank" rel="noopener" href="https://codeantenna.com/a/bGcgCLjKCk">https://codeantenna.com/a/bGcgCLjKCk</a></li>
<li><a target="_blank" rel="noopener" href="https://www.dounaite.com/article/628d0f2bf8519f4c0cd30f45.html">https://www.dounaite.com/article/628d0f2bf8519f4c0cd30f45.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/forfuture1978/p/3940965.html">tim tip</a></li>
<li><a target="_blank" rel="noopener" href="http://cmph.sourceforge.net/papers/chm92.pdf">An optimal algorithm for generating minimal perfect hash functions., Information Processing Letters</a></li>
<li><a target="_blank" rel="noopener" href="https://www.amazingkoala.com.cn/Lucene/Search/2020/0714/154.html">tim 文件,fst</a></li>
<li><a target="_blank" rel="noopener" href="https://www.amazingkoala.com.cn/Lucene/yasuocunchu/2019/0220/35.html">fst</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7067211930494042148">fst</a></li>
<li><a target="_blank" rel="noopener" href="https://www.shenyanchao.cn/blog/2018/12/04/lucene-fst/">fst</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wang_hnust/article/details/87988587">lucene arc fst</a></li>
<li><a target="_blank" rel="noopener" href="https://www.freesion.com/article/6984398617/">tim 读取和字段</a></li>
<li><a target="_blank" rel="noopener" href="https://www.merl.com/publications/docs/TR96-13.pdf">fst paper</a></li>
<li><a target="_blank" rel="noopener" href="https://cs.union.edu/~striegnk/courses/nlp-with-prolog/html/node13.html">相关阅读</a></li>
<li><a target="_blank" rel="noopener" href="https://www.6aiq.com/article/1586704007975">collect</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/studyhs/p/9088056.html">collect and reduce</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/alex_xfboy/article/details/90174840">mmap</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/384486147">fdt docment</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/sbp810050504/1533162">fdt 压缩和解压</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wang_hnust/article/details/88361568">fst term 读取和搜索</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sgyuanshi/article/details/105498418">搜索</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/studyhs/p/9092928.html">排序获取docid</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/studyhs/p/9088056.html">倒排索引pq定位</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI4Njk3NjU1OQ==&mid=2247484121&idx=1&sn=4450469c5ebd001c75214b58534e2c4e&chksm=ebd5fd99dca2748f41a8b3ff8867e31cf5124110a6649d7e3cc96a0395e238936b97f0b05b0f&scene=21#wechat_redirect">Impact 和topdoc定位docid</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/LGxYZ6plHAWVz7Mw6MAEtw">Impact 和topdoc定位docid</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/184983670">遍历doc</a></li>
<li><a target="_blank" rel="noopener" href="https://marian5211.github.io/2017/11/22/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8ETop-k%E5%BF%AB%E9%80%9F%E6%A3%80%E7%B4%A2%E9%97%AE%E9%A2%98/">topk</a></li>
<li><a target="_blank" rel="noopener" href="https://www.google.com/search?q=startFp+lucene&oq=startFp++lucene&aqs=chrome..69i57j33i160l4.6287j0j4&sourceid=chrome&ie=UTF-8">term相关索引</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b05eed0da6ad">tim 文件格式</a></li>
<li><a target="_blank" rel="noopener" href="http://examples.mikemccandless.com/fst.py?terms=&cmd=Build+it!">fst 例子</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/morfologik/morfologik-stemming">fst 工具github</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/news/380648">Burst Tries  BlockTree</a></li>
<li><a target="_blank" rel="noopener" href="https://www.amazingkoala.com.cn/Lucene/Index/2020/0528/144.html">TermId 和TermsDict</a></li>
<li><a target="_blank" rel="noopener" href="https://www.6aiq.com/article/1564413040138">lucene 文件结构</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shakudada.xyz/2021/10/18/llvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dinosaur">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dinosaur">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/18/llvm/" class="post-title-link" itemprop="url">llvm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-18 12:41:35" itemprop="dateCreated datePublished" datetime="2021-10-18T12:41:35+08:00">2021-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 11:42:47" itemprop="dateModified" datetime="2023-10-25T11:42:47+08:00">2023-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一个语言的前端主要是设计出来的</p>
<h4 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h4><ul>
<li><a target="_blank" rel="noopener" href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shakudada.xyz/2021/10/15/rabbitmq-ack-reject/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dinosaur">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dinosaur">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/15/rabbitmq-ack-reject/" class="post-title-link" itemprop="url">rabbitmq ack reject</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-15 11:22:23" itemprop="dateCreated datePublished" datetime="2021-10-15T11:22:23+08:00">2021-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 11:42:47" itemprop="dateModified" datetime="2023-10-25T11:42:47+08:00">2023-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>rabbitmq 分为3个状态</p>
<p>ack  reject  nack</p>
<h3 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/confirms.html">https://www.rabbitmq.com/confirms.html</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shakudada.xyz/2021/10/10/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dinosaur">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dinosaur">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/10/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">时间轮算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-10 21:54:28" itemprop="dateCreated datePublished" datetime="2021-10-10T21:54:28+08:00">2021-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 11:42:47" itemprop="dateModified" datetime="2023-10-25T11:42:47+08:00">2023-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Hashed and Hierarchical Timing Wheels:Data Structures for the Efficient Implementation of a Timer Facility</p>
<p>Conventional  algorithms  to  implement  an  Operating<br>System timer module take O(n) time to start or main-<br>rain  a  timer,  where  n  is  the  number    of outstanding<br>timers: this  is  expensive  for large  n. This  paper  be-<br>gins by exploring the relationship between timer algo-<br>rithms,  t i m e    flow  mechanisms  used  in  discrete  event<br>simulations, and  sorting  techniques. Next  a  timer<br>a l g o r i t h m    for  small  timer  intervals  is  presented  t h a t<br>is  similar to  the  timing wheel  technique used  in  logic<br>sinmlators.  By using a circular buffer or timing wheel,<br>it  takes  O(1)  time to start,  stop,  and m a i n t a i n   timers<br>within  the  range  of the  wheel.<br>T w o   extensions for larger values of the interval are de-<br>scribed.  In  the  first,  the  timer  interval is  hashed  into<br>a  slot on the  timing wheel.  In  the second,  a  hierarchy<br>of timing wheels with different granularities is used to<br>span  a  greater range of intervals.  T h e   performance of<br>these  two schemes  and various implementation trade-<br>offs are  discussed.<br>传统的操作系统定时器模块的算法复杂度是O(n) ,其中n是定时器的数量：当n很大的时候代价会非常昂贵 。<br>这篇文章开始探讨定时器算法和时间流机制在离散的事件模拟和排序技术方面的关系.下面的小间隔的定时器算法很类似使用逻辑模拟的时间轮.<br>通过使用环状缓冲或者时间轮,我们可以在定时器的可维持运行的精度内使用O(1)的时间去开启,结束以及维持定时器<br>有两个额外的对于大的时间间隔的拓展.第一,定时器的间隔被哈希进去一个时间轮.第二,一个多层级的时间轮保证大于时间间隔的也能有位置存放.<br>下面会讨论这两张情况和不同实现的平衡.</p>
<p>Our model of a timer module has four component<br>routines:<br>START_TIMER(Interval, Request_ID, Expiry_<br>Action): The client calls this routine to start a timer<br>that will expire after “Interval” units of time. The<br>client supplies a Request_ID which is used to distinguish this timer from other timers that the client has<br>outstanding. Finally, the client can specify what action must be taken on expiry: for instance, calling a<br>client-specified routine, or setting an event flag.<br>STOP_TIMER(Request_ID): This routine uses its<br>knowledge of the client and Request_ID to locate the<br>timer and stop it.<br>PER_TICK_BOOKKEEPING: Let the granularity of<br>the timer-be T units. Then every T units this routine<br>checks whether any outstanding timers have expired;<br>if so, it calls STOP_TIMER, which in turn calls the<br>next routine.<br>EXPIRY_PROCESSING: This routine does the Expiry_Action specified in the START_TIMER call.<br>The first two routines are activated on client calls<br>while the last two are invoked on timer ticks. The<br>timer is often an external hardware clock.<br>The following two performance measures can be used<br>to choose between the various algorithms described<br>in the rest of this paper. Both of them are parameterized by n, the average (or worst-case) number of<br>outstanding timers.<br>我们的定时器模块有四个组件模块例程:<br><code>START_TIMER(Interval, Request_ID, Expiry_Action)</code>: 客户端会调用这个例程去启动(注册)一个会在Interval 时间后会过期的定时器.</p>
<h3 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf">Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer fac</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">dinosaur</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">256</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">73</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/769344359" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;769344359" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/thedinosaurmail@gmail.com" title="E-Mail → thedinosaurmail@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dinosaur</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

</body>
</html>
