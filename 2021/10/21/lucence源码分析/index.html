<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"shakudada.xyz","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"79C1GXGOC6","apiKey":"225fa4bf2bc37c3e46a671682674fe37","indexName":"my-hexo-blog","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="lucene 分为两部分：  写入写入则是写入文件系统  查询则是通过了 分词、排序、topk提取等过程，获取对应的docid，再通过docid 回查对应的内容   Vintvint 是一个可变长的数组，是一个小端的变长数组，每个字节最高位置1代表后面还有（也就是最后一个字节的最高位是0） 相关代码12IndexWriterConfig iwc &#x3D; new IndexWriterConfig(an">
<meta property="og:type" content="article">
<meta property="og:title" content="lucene源码分析">
<meta property="og:url" content="https://shakudada.xyz/2021/10/21/lucence%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="dinosaur">
<meta property="og:description" content="lucene 分为两部分：  写入写入则是写入文件系统  查询则是通过了 分词、排序、topk提取等过程，获取对应的docid，再通过docid 回查对应的内容   Vintvint 是一个可变长的数组，是一个小端的变长数组，每个字节最高位置1代表后面还有（也就是最后一个字节的最高位是0） 相关代码12IndexWriterConfig iwc &#x3D; new IndexWriterConfig(an">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-10-21T05:01:36.000Z">
<meta property="article:modified_time" content="2023-10-25T03:42:47.907Z">
<meta property="article:author" content="dinosaur">
<meta property="article:tag" content="lucene">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://shakudada.xyz/2021/10/21/lucence%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>lucene源码分析 | dinosaur</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dinosaur</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shakudada.xyz/2021/10/21/lucence%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dinosaur">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dinosaur">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          lucene源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-21 13:01:36" itemprop="dateCreated datePublished" datetime="2021-10-21T13:01:36+08:00">2021-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 11:42:47" itemprop="dateModified" datetime="2023-10-25T11:42:47+08:00">2023-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>lucene 分为两部分：</p>
<ul>
<li><p>写入<br>写入则是写入文件系统</p>
</li>
<li><p>查询<br>则是通过了 分词、排序、topk提取等过程，获取对应的docid，再通过docid 回查对应的内容</p>
</li>
</ul>
<h2 id="Vint"><a href="#Vint" class="headerlink" title="Vint"></a>Vint</h2><p>vint 是一个可变长的数组，是一个小端的变长数组，每个字节最高位置<code>1</code>代表后面还有（也就是最后一个字节的最高位是0）</p>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IndexWriterConfig iwc = new IndexWriterConfig(analyzer);</span><br><span class="line">iwc.setUseCompoundFile(false);  // 生成多个文件</span><br></pre></td></tr></table></figure>

<h3 id="开始debug"><a href="#开始debug" class="headerlink" title="开始debug"></a>开始debug</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### 调试java 代码</span><br><span class="line"></span><br><span class="line"> java -agentlib:jdwp=transport=dt_socket,server=y,address=8000 -cp  ./lucene-demo-9.1.0-SNAPSHOT.jar:/home/ubuntu/lucene-9.1.0/lucene/core/build/libs/lucene-core-9.1.0-SNAPSHOT.jar:/home/ubuntu/lucene-9.1.0/lucene/queryparser/build/libs/lucene-queryparser-9.1.0-SNAPSHOT.jar    org.apache.lucene.demo.SearchFiles</span><br><span class="line"></span><br><span class="line">### jdb 连接上jdk</span><br><span class="line">jdb -attach 8000 -sourcepath /home/ubuntu/lucene-9.1.0/lucene/demo/src/java/</span><br></pre></td></tr></table></figure>

<h2 id="查看fdt文件"><a href="#查看fdt文件" class="headerlink" title="查看fdt文件"></a>查看fdt文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C _0.fdt</span><br><span class="line">00000000  3f d7 6c 17 1c 4c 75 63  65 6e 65 39 30 53 74 6f  |?.l..Lucene90Sto|</span><br><span class="line">00000010  72 65 64 46 69 65 6c 64  73 46 61 73 74 44 61 74  |redFieldsFastDat|</span><br><span class="line">00000020  61 00 00 00 01 85 88 12  2b 0c 73 6b 95 30 38 76  |a.......+.sk.08v|</span><br><span class="line">00000030  c9 0a 2a 52 29 00 00 0a  00 01 00 1c 02 06 03 07  |..*R)...........|</span><br><span class="line">00000040  07 07 07 07 07 07 07 07  20 00 1a 60 2f 68 6f 6d  |........ ..`/hom|</span><br><span class="line">00000050  65 2f 60 75 62 75 6e 74  75 60 2f 64 6f 63 2f 6d  |e/`ubuntu`/doc/m|</span><br><span class="line">00000060  60 6f 6e 67 6f 2e 74 60  78 74 00 1a 2f 68 60 6f  |`ongo.t`xt../h`o|</span><br><span class="line">00000070  6d 65 2f 75 62 60 75 6e  74 75 2f 64 60 6f 63 2f  |me/ub`untu/d`oc/|</span><br><span class="line">00000080  68 65 6c 60 6c 6f 2e 74  78 74 c0 28 93 e8 00 00  |hel`lo.txt.(....|</span><br><span class="line">00000090  00 00 00 00 00 00 c8 75  0a 41                    |.......u.A|</span><br><span class="line">0000009a</span><br></pre></td></tr></table></figure>
<h2 id="writeField"><a href="#writeField" class="headerlink" title="writeField"></a>writeField</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~$ jdb -attach 8000 -sourcepath /home/ubuntu/lucene-9.1.0/lucene/demo/src/java/:/home/ubuntu/lucene-9.1.0/lucene/core/src/java/ </span><br><span class="line">Set uncaught java.lang.Throwable</span><br><span class="line">Set deferred uncaught java.lang.Throwable</span><br><span class="line">Initializing jdb ...</span><br><span class="line">&gt; </span><br><span class="line">VM Started: No frames on the current call stack</span><br><span class="line"></span><br><span class="line">main[1] stop in  org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsWriter.writeField</span><br><span class="line">Deferring breakpoint org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsWriter.writeField.</span><br><span class="line">It will be set after the class is loaded.</span><br><span class="line">main[1] cont</span><br><span class="line">&gt; Set deferred breakpoint org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsWriter.writeField</span><br><span class="line"></span><br><span class="line">Breakpoint hit: &quot;thread=main&quot;, org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsWriter.writeField(), line=276 bci=0</span><br><span class="line">276        ++numStoredFieldsInDoc;</span><br><span class="line"></span><br><span class="line">main[1] wheree^H^H</span><br><span class="line">Unrecognized command: &#x27;wher&#x27;.  Try help...</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsWriter.writeField (Lucene90CompressingStoredFieldsWriter.java:276)</span><br><span class="line">  [2] org.apache.lucene.index.StoredFieldsConsumer.writeField (StoredFieldsConsumer.java:65)</span><br><span class="line">  [3] org.apache.lucene.index.IndexingChain.processField (IndexingChain.java:749)</span><br><span class="line">  [4] org.apache.lucene.index.IndexingChain.processDocument (IndexingChain.java:620)</span><br><span class="line">  [5] org.apache.lucene.index.DocumentsWriterPerThread.updateDocuments (DocumentsWriterPerThread.java:241)</span><br><span class="line">  [6] org.apache.lucene.index.DocumentsWriter.updateDocuments (DocumentsWriter.java:432)</span><br><span class="line">  [7] org.apache.lucene.index.IndexWriter.updateDocuments (IndexWriter.java:1,531)</span><br><span class="line">  [8] org.apache.lucene.index.IndexWriter.updateDocument (IndexWriter.java:1,816)</span><br><span class="line">  [9] org.apache.lucene.index.IndexWriter.addDocument (IndexWriter.java:1,469)</span><br><span class="line">  [10] org.apache.lucene.demo.IndexFiles.indexDoc (IndexFiles.java:271)</span><br><span class="line">  [11] org.apache.lucene.demo.IndexFiles$1.visitFile (IndexFiles.java:212)</span><br><span class="line">  [12] org.apache.lucene.demo.IndexFiles$1.visitFile (IndexFiles.java:208)</span><br><span class="line">  [13] java.nio.file.Files.walkFileTree (Files.java:2,725)</span><br><span class="line">  [14] java.nio.file.Files.walkFileTree (Files.java:2,797)</span><br><span class="line">  [15] org.apache.lucene.demo.IndexFiles.indexDocs (IndexFiles.java:206)</span><br><span class="line">  [16] org.apache.lucene.demo.IndexFiles.main (IndexFiles.java:157)</span><br><span class="line">main[1] list</span><br><span class="line">272    </span><br><span class="line">273      @Override</span><br><span class="line">274      public void writeField(FieldInfo info, IndexableField field) throws IOException &#123;</span><br><span class="line">275    </span><br><span class="line">276 =&gt;     ++numStoredFieldsInDoc;</span><br><span class="line">277    </span><br><span class="line">278        int bits = 0;</span><br><span class="line">279        final BytesRef bytes;</span><br><span class="line">280        final String string;</span><br><span class="line">281    </span><br><span class="line">main[1] print field</span><br><span class="line"> field = &quot;stored,indexed,omitNorms,indexOptions=DOCS&lt;path:/home/ubuntu/doc/mongo.txt&gt;&quot;</span><br><span class="line">main[1] print info</span><br><span class="line"> info = &quot;org.apache.lucene.index.FieldInfo@32464a14&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分词和倒排索引"><a href="#分词和倒排索引" class="headerlink" title="分词和倒排索引"></a>分词和倒排索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.index.IndexingChain$PerField.invert (IndexingChain.java:1,138)</span><br><span class="line">  [2] org.apache.lucene.index.IndexingChain.processField (IndexingChain.java:729)</span><br><span class="line">  [3] org.apache.lucene.index.IndexingChain.processDocument (IndexingChain.java:620)</span><br><span class="line">  [4] org.apache.lucene.index.DocumentsWriterPerThread.updateDocuments (DocumentsWriterPerThread.java:241)</span><br><span class="line">  [5] org.apache.lucene.index.DocumentsWriter.updateDocuments (DocumentsWriter.java:432)</span><br><span class="line">  [6] org.apache.lucene.index.IndexWriter.updateDocuments (IndexWriter.java:1,531)</span><br><span class="line">  [7] org.apache.lucene.index.IndexWriter.updateDocument (IndexWriter.java:1,816)</span><br><span class="line">  [8] org.apache.lucene.demo.IndexFiles.indexDoc (IndexFiles.java:277)</span><br><span class="line">  [9] org.apache.lucene.demo.IndexFiles$1.visitFile (IndexFiles.java:212)</span><br><span class="line">  [10] org.apache.lucene.demo.IndexFiles$1.visitFile (IndexFiles.java:208)</span><br><span class="line">  [11] java.nio.file.Files.walkFileTree (Files.java:2,725)</span><br><span class="line">  [12] java.nio.file.Files.walkFileTree (Files.java:2,797)</span><br><span class="line">  [13] org.apache.lucene.demo.IndexFiles.indexDocs (IndexFiles.java:206)</span><br><span class="line">  [14] org.apache.lucene.demo.IndexFiles.main (IndexFiles.java:157)</span><br></pre></td></tr></table></figure>

<h3 id="term描述"><a href="#term描述" class="headerlink" title="term描述"></a>term描述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntBlockPool intPool,</span><br><span class="line">ByteBlockPool bytePool,</span><br><span class="line">ByteBlockPool termBytePool,</span><br></pre></td></tr></table></figure>

<p>倒排索引term 在内存中用以下内容描述：<br><code>intPool</code> 包含三个变量:</p>
<ul>
<li>二维数组<code>buffers[][]</code></li>
<li><code>int bufferUpto</code> 描述的是二维数组 <code>buffers[][]</code>的第一级的偏移 ， 一般都是这样用 <code>int[]  buff = buffers[bufferUpto + offset]</code></li>
<li><code>int intUpto</code> 描述的是整体的偏移量,描述是偏移所有的buffers 的字节数</li>
<li><code>int intOffset</code> 描述的是<code>header buffer</code>的偏移量</li>
</ul>
<p>那么<code>buffers[xxx][yyy]</code>的值又是什么呢？<br>这个<code>buffers</code>二维数组存的也是偏移量.是什么的偏移量呢？</p>
<p><code>intPool</code>描述的是<code>bytePool</code> 和<code>termBytePool</code> 的偏移量</p>
<h3 id="term-写入tim文件"><a href="#term-写入tim文件" class="headerlink" title="term 写入tim文件"></a>term 写入tim文件</h3><p>会将term一个个写入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main[1] where </span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.blocktree.Lucene90BlockTreeTermsWriter$TermsWriter.writeBlock (Lucene90BlockTreeTermsWriter.java:963)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.blocktree.Lucene90BlockTreeTermsWriter$TermsWriter.writeBlocks (Lucene90BlockTreeTermsWriter.java:709)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.blocktree.Lucene90BlockTreeTermsWriter$TermsWriter.finish (Lucene90BlockTreeTermsWriter.java:1,105)</span><br><span class="line">  [4] org.apache.lucene.codecs.lucene90.blocktree.Lucene90BlockTreeTermsWriter.write (Lucene90BlockTreeTermsWriter.java:370)</span><br><span class="line">  [5] org.apache.lucene.codecs.perfield.PerFieldPostingsFormat$FieldsWriter.write (PerFieldPostingsFormat.java:171)</span><br><span class="line">  [6] org.apache.lucene.index.FreqProxTermsWriter.flush (FreqProxTermsWriter.java:131)</span><br><span class="line">  [7] org.apache.lucene.index.IndexingChain.flush (IndexingChain.java:300)</span><br><span class="line">  [8] org.apache.lucene.index.DocumentsWriterPerThread.flush (DocumentsWriterPerThread.java:391)</span><br><span class="line">  [9] org.apache.lucene.index.DocumentsWriter.doFlush (DocumentsWriter.java:493)</span><br><span class="line">  [10] org.apache.lucene.index.DocumentsWriter.flushAllThreads (DocumentsWriter.java:672)</span><br><span class="line">  [11] org.apache.lucene.index.IndexWriter.doFlush (IndexWriter.java:4,014)</span><br><span class="line">  [12] org.apache.lucene.index.IndexWriter.flush (IndexWriter.java:3,988)</span><br><span class="line">  [13] org.apache.lucene.index.IndexWriter.shutdown (IndexWriter.java:1,321)</span><br><span class="line">  [14] org.apache.lucene.index.IndexWriter.close (IndexWriter.java:1,361)</span><br><span class="line">  [15] org.apache.lucene.demo.IndexFiles.main (IndexFiles.java:166)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.TopScoreDocCollector$SimpleTopScoreDocCollector.getLeafCollector (TopScoreDocCollector.java:57)</span><br><span class="line">  [2] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:759)</span><br><span class="line">  [3] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [7] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [8] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="获取term"><a href="#获取term" class="headerlink" title="获取term"></a>获取term</h3><p>从terms reader 读取term</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main[1] print fieldMap.get(field)</span><br><span class="line"> fieldMap.get(field) = &quot;BlockTreeTerms(seg=_j terms=18,postings=20,positions=25,docs=2)&quot;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.blocktree.Lucene90BlockTreeTermsReader.terms (Lucene90BlockTreeTermsReader.java:294)</span><br><span class="line">  [2] org.apache.lucene.codecs.perfield.PerFieldPostingsFormat$FieldsReader.terms (PerFieldPostingsFormat.java:353)</span><br><span class="line">  [3] org.apache.lucene.index.CodecReader.terms (CodecReader.java:114)</span><br><span class="line">  [4] org.apache.lucene.index.Terms.getTerms (Terms.java:41)</span><br><span class="line">  [5] org.apache.lucene.index.TermStates.loadTermsEnum (TermStates.java:115)</span><br><span class="line">  [6] org.apache.lucene.index.TermStates.build (TermStates.java:102)</span><br><span class="line">  [7] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [10] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [11] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [12] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [13] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="通过arc-获取对应output"><a href="#通过arc-获取对应output" class="headerlink" title="通过arc 获取对应output"></a>通过arc 获取对应output</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hit: &quot;thread=main&quot;, org.apache.lucene.util.fst.FST.findTargetArc(), line=1,412 bci=0</span><br><span class="line">1,412        if (labelToMatch == END_LABEL) &#123;</span><br><span class="line"></span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.util.fst.FST.findTargetArc (FST.java:1,412)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.seekExact (SegmentTermsEnum.java:511)</span><br><span class="line">  [3] org.apache.lucene.index.TermStates.loadTermsEnum (TermStates.java:117)</span><br><span class="line">  [4] org.apache.lucene.index.TermStates.build (TermStates.java:102)</span><br><span class="line">  [5] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="打开tim文件"><a href="#打开tim文件" class="headerlink" title="打开tim文件"></a>打开tim文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.blocktree.Lucene90BlockTreeTermsReader.&lt;init&gt; (Lucene90BlockTreeTermsReader.java:135)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.Lucene90PostingsFormat.fieldsProducer (Lucene90PostingsFormat.java:427)</span><br><span class="line">  [3] org.apache.lucene.codecs.perfield.PerFieldPostingsFormat$FieldsReader.&lt;init&gt; (PerFieldPostingsFormat.java:329)</span><br><span class="line">  [4] org.apache.lucene.codecs.perfield.PerFieldPostingsFormat.fieldsProducer (PerFieldPostingsFormat.java:391)</span><br><span class="line">  [5] org.apache.lucene.index.SegmentCoreReaders.&lt;init&gt; (SegmentCoreReaders.java:118)</span><br><span class="line">  [6] org.apache.lucene.index.SegmentReader.&lt;init&gt; (SegmentReader.java:91)</span><br><span class="line">  [7] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:94)</span><br><span class="line">  [8] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:77)</span><br><span class="line">  [9] org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run (SegmentInfos.java:809)</span><br><span class="line">  [10] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:109)</span><br><span class="line">  [11] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:67)</span><br><span class="line">  [12] org.apache.lucene.index.DirectoryReader.open (DirectoryReader.java:60)</span><br><span class="line">  [13] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:105)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取topk的数据核心函数<code>mergeAux</code>,一个辅助函数获取topk的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Step completed: &quot;thread=main&quot;, org.apache.lucene.search.TopDocs.mergeAux(), line=291 bci=43</span><br><span class="line">291        for (int shardIDX = 0; shardIDX &lt; shardHits.length; shardIDX++) &#123;</span><br><span class="line"></span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.TopDocs.mergeAux (TopDocs.java:291)</span><br><span class="line">  [2] org.apache.lucene.search.TopDocs.merge (TopDocs.java:216)</span><br><span class="line">  [3] org.apache.lucene.search.IndexSearcher$2.reduce (IndexSearcher.java:528)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher$2.reduce (IndexSearcher.java:505)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:694)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br></pre></td></tr></table></figure>






<h2 id="docid-获取对应的文案内容"><a href="#docid-获取对应的文案内容" class="headerlink" title="docid 获取对应的文案内容"></a><code>docid</code> 获取对应的文案内容</h2><h3 id="通过docid-获取document"><a href="#通过docid-获取document" class="headerlink" title="通过docid 获取document"></a>通过docid 获取document</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.store.ByteBufferIndexInput$SingleBufferImpl.seek (ByteBufferIndexInput.java:529)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader$BlockState.document (Lucene90CompressingStoredFieldsReader.java:594)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.document (Lucene90CompressingStoredFieldsReader.java:610)</span><br><span class="line">  [4] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.visitDocument (Lucene90CompressingStoredFieldsReader.java:628)</span><br><span class="line">  [5] org.apache.lucene.index.CodecReader.document (CodecReader.java:89)</span><br><span class="line">  [6] org.apache.lucene.index.BaseCompositeReader.document (BaseCompositeReader.java:154)</span><br><span class="line">  [7] org.apache.lucene.index.IndexReader.document (IndexReader.java:380)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.doc (IndexSearcher.java:380)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:214)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>
<p>seek 方法通过偏移获取document,其中seek 中<code>curBuf</code> 是<code>java.nio.DirectByteBufferR</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">525    </span><br><span class="line">526        @Override</span><br><span class="line">527        public void seek(long pos) throws IOException &#123;</span><br><span class="line">528          try &#123;</span><br><span class="line">529 =&gt;         curBuf.position((int) pos);</span><br><span class="line">530          &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">531            if (pos &lt; 0) &#123;</span><br><span class="line">532              throw new IllegalArgumentException(&quot;Seeking to negative position: &quot; + this, e);</span><br><span class="line">533            &#125; else &#123;</span><br><span class="line">534              throw new EOFException(&quot;seek past EOF: &quot; + this);</span><br><span class="line">main[1] print curBuf</span><br><span class="line"> curBuf = &quot;java.nio.DirectByteBufferR[pos=60 lim=154 cap=154]&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">168    </span><br><span class="line">169      // NOTE: AIOOBE not EOF if you read too much</span><br><span class="line">170      @Override</span><br><span class="line">171      public void readBytes(byte[] b, int offset, int len) &#123;</span><br><span class="line">172 =&gt;     System.arraycopy(bytes, pos, b, offset, len);</span><br><span class="line">173        pos += len;</span><br><span class="line">174      &#125;</span><br><span class="line">175    &#125;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.store.ByteArrayDataInput.readBytes (ByteArrayDataInput.java:172)</span><br><span class="line">  [2] org.apache.lucene.store.DataInput.readString (DataInput.java:265)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.readField (Lucene90CompressingStoredFieldsReader.java:246)</span><br><span class="line">  [4] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.visitDocument (Lucene90CompressingStoredFieldsReader.java:640)</span><br><span class="line">  [5] org.apache.lucene.index.CodecReader.document (CodecReader.java:89)</span><br><span class="line">  [6] org.apache.lucene.index.BaseCompositeReader.document (BaseCompositeReader.java:154)</span><br><span class="line">  [7] org.apache.lucene.index.IndexReader.document (IndexReader.java:380)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.doc (IndexSearcher.java:380)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:214)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>


<h3 id="通过堆外内存加载文件数据"><a href="#通过堆外内存加载文件数据" class="headerlink" title="通过堆外内存加载文件数据"></a>通过堆外内存加载文件数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hit: &quot;thread=main&quot;, org.apache.lucene.store.ByteBufferIndexInput.setCurBuf(), line=83 bci=0</span><br><span class="line">83        this.curBuf = curBuf;</span><br><span class="line"></span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.store.ByteBufferIndexInput.setCurBuf (ByteBufferIndexInput.java:83)</span><br><span class="line">  [2] org.apache.lucene.store.ByteBufferIndexInput$SingleBufferImpl.&lt;init&gt; (ByteBufferIndexInput.java:520)</span><br><span class="line">  [3] org.apache.lucene.store.ByteBufferIndexInput.newInstance (ByteBufferIndexInput.java:60)</span><br><span class="line">  [4] org.apache.lucene.store.MMapDirectory.openInput (MMapDirectory.java:238)</span><br><span class="line">  [5] org.apache.lucene.store.Directory.openChecksumInput (Directory.java:152)</span><br><span class="line">  [6] org.apache.lucene.index.SegmentInfos.readCommit (SegmentInfos.java:297)</span><br><span class="line">  [7] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:88)</span><br><span class="line">  [8] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:77)</span><br><span class="line">  [9] org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run (SegmentInfos.java:809)</span><br><span class="line">  [10] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:109)</span><br><span class="line">  [11] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:67)</span><br><span class="line">  [12] org.apache.lucene.index.DirectoryReader.open (DirectoryReader.java:60)</span><br><span class="line">  [13] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:105)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="filechannel-的-map"><a href="#filechannel-的-map" class="headerlink" title="filechannel 的 map"></a>filechannel 的 map</h3><p>java 对应的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src\java.base\share\classes\sun\nio\ch\FileChannelImpl.java</span><br><span class="line">    // Creates a new mapping</span><br><span class="line">    private native long map0(int prot, long position, long length, boolean isSync)</span><br><span class="line">        throws IOException;</span><br></pre></td></tr></table></figure>

<p>native 对应的c实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">src\java.base\unix\native\libnio\ch\FileChannelImpl.c</span><br><span class="line">JNIEXPORT jlong JNICALL</span><br><span class="line">Java_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject this,</span><br><span class="line">                                     jint prot, jlong off, jlong len, jboolean map_sync)</span><br><span class="line">&#123;</span><br><span class="line">    void *mapAddress = 0;</span><br><span class="line">    jobject fdo = (*env)-&gt;GetObjectField(env, this, chan_fd);</span><br><span class="line">    jint fd = fdval(env, fdo);</span><br><span class="line">    int protections = 0;</span><br><span class="line">    int flags = 0;</span><br><span class="line"></span><br><span class="line">    // should never be called with map_sync and prot == PRIVATE</span><br><span class="line">    assert((prot != sun_nio_ch_FileChannelImpl_MAP_PV) || !map_sync);</span><br><span class="line"></span><br><span class="line">    if (prot == sun_nio_ch_FileChannelImpl_MAP_RO) &#123;</span><br><span class="line">        protections = PROT_READ;</span><br><span class="line">        flags = MAP_SHARED;</span><br><span class="line">    &#125; else if (prot == sun_nio_ch_FileChannelImpl_MAP_RW) &#123;</span><br><span class="line">        protections = PROT_WRITE | PROT_READ;</span><br><span class="line">        flags = MAP_SHARED;</span><br><span class="line">    &#125; else if (prot == sun_nio_ch_FileChannelImpl_MAP_PV) &#123;</span><br><span class="line">        protections =  PROT_WRITE | PROT_READ;</span><br><span class="line">        flags = MAP_PRIVATE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // if MAP_SYNC and MAP_SHARED_VALIDATE are not defined then it is</span><br><span class="line">    // best to define them here. This ensures the code compiles on old</span><br><span class="line">    // OS releases which do not provide the relevant headers. If run</span><br><span class="line">    // on the same machine then it will work if the kernel contains</span><br><span class="line">    // the necessary support otherwise mmap should fail with an</span><br><span class="line">    // invalid argument error</span><br><span class="line"></span><br><span class="line">#ifndef MAP_SYNC</span><br><span class="line">#define MAP_SYNC 0x80000</span><br><span class="line">#endif</span><br><span class="line">#ifndef MAP_SHARED_VALIDATE</span><br><span class="line">#define MAP_SHARED_VALIDATE 0x03</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    if (map_sync) &#123;</span><br><span class="line">        // ensure</span><br><span class="line">        //  1) this is Linux on AArch64, x86_64, or PPC64 LE</span><br><span class="line">        //  2) the mmap APIs are available at compile time</span><br><span class="line">#if !defined(LINUX) || ! (defined(aarch64) || (defined(amd64) &amp;&amp; defined(_LP64)) || defined(ppc64le))</span><br><span class="line">        // TODO - implement for solaris/AIX/BSD/WINDOWS and for 32 bit</span><br><span class="line">        JNU_ThrowInternalError(env, &quot;should never call map on platform where MAP_SYNC is unimplemented&quot;);</span><br><span class="line">        return IOS_THROWN;</span><br><span class="line">#else</span><br><span class="line">        flags |= MAP_SYNC | MAP_SHARED_VALIDATE;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapAddress = mmap64(</span><br><span class="line">        0,                    /* Let OS decide location */</span><br><span class="line">        len,                  /* Number of bytes to map */</span><br><span class="line">        protections,          /* File permissions */</span><br><span class="line">        flags,                /* Changes are shared */</span><br><span class="line">        fd,                   /* File descriptor of mapped file */</span><br><span class="line">        off);                 /* Offset into file */</span><br><span class="line"></span><br><span class="line">    if (mapAddress == MAP_FAILED) &#123;</span><br><span class="line">        if (map_sync &amp;&amp; errno == ENOTSUP) &#123;</span><br><span class="line">            JNU_ThrowIOExceptionWithLastError(env, &quot;map with mode MAP_SYNC unsupported&quot;);</span><br><span class="line">            return IOS_THROWN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (errno == ENOMEM) &#123;</span><br><span class="line">            JNU_ThrowOutOfMemoryError(env, &quot;Map failed&quot;);</span><br><span class="line">            return IOS_THROWN;</span><br><span class="line">        &#125;</span><br><span class="line">        return handle(env, -1, &quot;Map failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ((jlong) (unsigned long) mapAddress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="mmap-映射文件读取硬盘中的内容"><a href="#mmap-映射文件读取硬盘中的内容" class="headerlink" title="mmap 映射文件读取硬盘中的内容"></a>mmap 映射文件读取硬盘中的内容</h4><p><code>FileChannel.open</code> 底层是一个native方法,如果是linux系统,就是<code>mmap64</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">228    </span><br><span class="line">229      /** Creates an IndexInput for the file with the given name. */</span><br><span class="line">230      @Override</span><br><span class="line">231      public IndexInput openInput(String name, IOContext context) throws IOException &#123;</span><br><span class="line">232 =&gt;     ensureOpen();</span><br><span class="line">233        ensureCanRead(name);</span><br><span class="line">234        Path path = directory.resolve(name);</span><br><span class="line">235        try (FileChannel c = FileChannel.open(path, StandardOpenOption.READ)) &#123;</span><br><span class="line">236          final String resourceDescription = &quot;MMapIndexInput(path=\&quot;&quot; + path.toString() + &quot;\&quot;)&quot;;</span><br><span class="line">237          final boolean useUnmap = getUseUnmap();</span><br><span class="line">main[1] print name</span><br><span class="line"> name = &quot;_j.fnm&quot;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.store.MMapDirectory.openInput (MMapDirectory.java:232)</span><br><span class="line">  [2] org.apache.lucene.store.Directory.openChecksumInput (Directory.java:152)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.Lucene90FieldInfosFormat.read (Lucene90FieldInfosFormat.java:124)</span><br><span class="line">  [4] org.apache.lucene.index.SegmentCoreReaders.&lt;init&gt; (SegmentCoreReaders.java:111)</span><br><span class="line">  [5] org.apache.lucene.index.SegmentReader.&lt;init&gt; (SegmentReader.java:91)</span><br><span class="line">  [6] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:94)</span><br><span class="line">  [7] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:77)</span><br><span class="line">  [8] org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run (SegmentInfos.java:809)</span><br><span class="line">  [9] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:109)</span><br><span class="line">  [10] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:67)</span><br><span class="line">  [11] org.apache.lucene.index.DirectoryReader.open (DirectoryReader.java:60)</span><br><span class="line">  [12] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:105)</span><br></pre></td></tr></table></figure>



<h4 id="读取mmap后的数据"><a href="#读取mmap后的数据" class="headerlink" title="读取mmap后的数据"></a>读取mmap后的数据</h4><p>mmap之后的buf在哪里会被用到呢?<br>和普通的文件读写类似,也就是seek后读字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">lucene\core\src\java\org\apache\lucene\store\ByteBufferIndexInput.java</span><br><span class="line">  @Override</span><br><span class="line">  public final void readBytes(byte[] b, int offset, int len) throws IOException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      guard.getBytes(curBuf, b, offset, len);</span><br><span class="line">    &#125; catch (</span><br><span class="line">        @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">        BufferUnderflowException e) &#123;</span><br><span class="line">      int curAvail = curBuf.remaining();</span><br><span class="line">      while (len &gt; curAvail) &#123;</span><br><span class="line">        guard.getBytes(curBuf, b, offset, curAvail);</span><br><span class="line">        len -= curAvail;</span><br><span class="line">        offset += curAvail;</span><br><span class="line">        curBufIndex++;</span><br><span class="line">        if (curBufIndex &gt;= buffers.length) &#123;</span><br><span class="line">          throw new EOFException(&quot;read past EOF: &quot; + this);</span><br><span class="line">        &#125;</span><br><span class="line">        setCurBuf(buffers[curBufIndex]);</span><br><span class="line">        curBuf.position(0);</span><br><span class="line">        curAvail = curBuf.remaining();</span><br><span class="line">      &#125;</span><br><span class="line">      guard.getBytes(curBuf, b, offset, len);</span><br><span class="line">    &#125; catch (</span><br><span class="line">        @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">        NullPointerException npe) &#123;</span><br><span class="line">      throw new AlreadyClosedException(&quot;Already closed: &quot; + this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>mmap后读取数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] jdk.internal.misc.Unsafe.copyMemory (Unsafe.java:782)</span><br><span class="line">  [2] java.nio.DirectByteBuffer.get (DirectByteBuffer.java:308)</span><br><span class="line">  [3] org.apache.lucene.store.ByteBufferGuard.getBytes (ByteBufferGuard.java:93)</span><br><span class="line">  [4] org.apache.lucene.store.ByteBufferIndexInput.readBytes (ByteBufferIndexInput.java:114)</span><br><span class="line">  [5] org.apache.lucene.store.BufferedChecksumIndexInput.readBytes (BufferedChecksumIndexInput.java:46)</span><br><span class="line">  [6] org.apache.lucene.store.DataInput.readString (DataInput.java:265)</span><br><span class="line">  [7] org.apache.lucene.codecs.CodecUtil.checkHeaderNoMagic (CodecUtil.java:202)</span><br><span class="line">  [8] org.apache.lucene.codecs.CodecUtil.checkHeader (CodecUtil.java:193)</span><br><span class="line">  [9] org.apache.lucene.codecs.CodecUtil.checkIndexHeader (CodecUtil.java:253)</span><br><span class="line">  [10] org.apache.lucene.codecs.lucene90.Lucene90FieldInfosFormat.read (Lucene90FieldInfosFormat.java:128)</span><br><span class="line">  [11] org.apache.lucene.index.SegmentCoreReaders.&lt;init&gt; (SegmentCoreReaders.java:111)</span><br><span class="line">  [12] org.apache.lucene.index.SegmentReader.&lt;init&gt; (SegmentReader.java:91)</span><br><span class="line">  [13] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:94)</span><br><span class="line">  [14] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:77)</span><br><span class="line">  [15] org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run (SegmentInfos.java:809)</span><br><span class="line">  [16] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:109)</span><br><span class="line">  [17] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:67)</span><br><span class="line">  [18] org.apache.lucene.index.DirectoryReader.open (DirectoryReader.java:60)</span><br><span class="line">  [19] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:105)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="文件格式介绍"><a href="#文件格式介绍" class="headerlink" title="文件格式介绍"></a>文件格式介绍</h2><h3 id="fnm-文件"><a href="#fnm-文件" class="headerlink" title=".fnm 文件"></a>.fnm 文件</h3><p><a target="_blank" rel="noopener" href="https://lucene.apache.org/core/9_0_0/core/org/apache/lucene/codecs/lucene90/Lucene90FieldInfosFormat.html">格式出处</a></p>
<p>fnm 文件 由这几部分组成:</p>
<ul>
<li>Header</li>
<li>FieldsCount : 字段的个数</li>
<li>数组,长度为FieldsCount , 数组中每个元素包含包含这几个字段: [FieldName: 字段名 ,FieldNumber:字段number ,FieldBits, DocValuesBits,  DocValuesGen ,DimensionCount , DimensionNumBytes ]</li>
<li>Footer</li>
</ul>
<p>fnm 描述的field的基础信息,也可以算是metadata信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">Field names are stored in the field info file, with suffix .fnm.</span><br><span class="line"></span><br><span class="line">FieldInfos (.fnm) --&gt; Header,FieldsCount, &lt;FieldName,FieldNumber, FieldBits,DocValuesBits,DocValuesGen,Attributes,DimensionCount,DimensionNumBytes&gt; ,Footer</span><br><span class="line"></span><br><span class="line">Data types:</span><br><span class="line"></span><br><span class="line">Header --&gt; IndexHeader</span><br><span class="line">FieldsCount --&gt; VInt</span><br><span class="line">FieldName --&gt; String</span><br><span class="line">FieldBits, IndexOptions, DocValuesBits --&gt; Byte</span><br><span class="line">FieldNumber, DimensionCount, DimensionNumBytes --&gt; VInt</span><br><span class="line">Attributes --&gt; Map&lt;String,String&gt;</span><br><span class="line">DocValuesGen --&gt; Int64</span><br><span class="line">Footer --&gt; CodecFooter</span><br><span class="line">Field Descriptions:</span><br><span class="line">FieldsCount: the number of fields in this file.</span><br><span class="line">FieldName: name of the field as a UTF-8 String.</span><br><span class="line">FieldNumber: the field&#x27;s number. Note that unlike previous versions of Lucene, the fields are not numbered implicitly by their order in the file, instead explicitly.</span><br><span class="line">FieldBits: a byte containing field options.</span><br><span class="line">The low order bit (0x1) is one for fields that have term vectors stored, and zero for fields without term vectors.</span><br><span class="line">If the second lowest order-bit is set (0x2), norms are omitted for the indexed field.</span><br><span class="line">If the third lowest-order bit is set (0x4), payloads are stored for the indexed field.</span><br><span class="line">IndexOptions: a byte containing index options.</span><br><span class="line">0: not indexed</span><br><span class="line">1: indexed as DOCS_ONLY</span><br><span class="line">2: indexed as DOCS_AND_FREQS</span><br><span class="line">3: indexed as DOCS_AND_FREQS_AND_POSITIONS</span><br><span class="line">4: indexed as DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS</span><br><span class="line">DocValuesBits: a byte containing per-document value types. The type recorded as two four-bit integers, with the high-order bits representing norms options, and the low-order bits representing DocValues options. Each four-bit integer can be decoded as such:</span><br><span class="line">0: no DocValues for this field.</span><br><span class="line">1: NumericDocValues. (DocValuesType.NUMERIC)</span><br><span class="line">2: BinaryDocValues. (DocValuesType#BINARY)</span><br><span class="line">3: SortedDocValues. (DocValuesType#SORTED)</span><br><span class="line">DocValuesGen is the generation count of the field&#x27;s DocValues. If this is -1, there are no DocValues updates to that field. Anything above zero means there are updates stored by DocValuesFormat.</span><br><span class="line">Attributes: a key-value map of codec-private attributes.</span><br><span class="line">PointDimensionCount, PointNumBytes: these are non-zero only if the field is indexed as points, e.g. using LongPoint</span><br><span class="line">VectorDimension: it is non-zero if the field is indexed as vectors.</span><br><span class="line">VectorSimilarityFunction: a byte containing distance function used for similarity calculation.</span><br><span class="line">0: EUCLIDEAN distance. (VectorSimilarityFunction.EUCLIDEAN)</span><br><span class="line">1: DOT_PRODUCT similarity. (VectorSimilarityFunction.DOT_PRODUCT)</span><br><span class="line">2: COSINE similarity. (VectorSimilarityFunction.COSINE)</span><br></pre></td></tr></table></figure>


<h3 id="fdt"><a href="#fdt" class="headerlink" title=".fdt"></a>.fdt</h3><p>文件路径: <code>lucene\backward-codecs\src\java\org\apache\lucene\backward_codecs\lucene50\Lucene50CompoundFormat.java</code>  </p>
<p>没有找到90的版本的fdt格式,只有2.9.4的,将就使用<a target="_blank" rel="noopener" href="https://lucene.apache.org/core/2_9_4/fileformats.html#field_data">fdt格式</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main[1] print fieldsStreamFN</span><br><span class="line"> fieldsStreamFN = &quot;_j.fdt&quot;</span><br><span class="line">main[1] list</span><br><span class="line">124        numDocs = si.maxDoc();</span><br><span class="line">125    </span><br><span class="line">126        final String fieldsStreamFN =</span><br><span class="line">127            IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION);</span><br><span class="line">128 =&gt;     ChecksumIndexInput metaIn = null;</span><br><span class="line">129        try &#123;</span><br><span class="line">130          // Open the data file</span><br><span class="line">131          fieldsStream = d.openInput(fieldsStreamFN, context);</span><br><span class="line">132          version =</span><br><span class="line">133              CodecUtil.checkIndexHeader(</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.&lt;init&gt; (Lucene90CompressingStoredFieldsReader.java:128)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsFormat.fieldsReader (Lucene90CompressingStoredFieldsFormat.java:133)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.Lucene90StoredFieldsFormat.fieldsReader (Lucene90StoredFieldsFormat.java:136)</span><br><span class="line">  [4] org.apache.lucene.index.SegmentCoreReaders.&lt;init&gt; (SegmentCoreReaders.java:138)</span><br><span class="line">  [5] org.apache.lucene.index.SegmentReader.&lt;init&gt; (SegmentReader.java:91)</span><br><span class="line">  [6] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:94)</span><br><span class="line">  [7] org.apache.lucene.index.StandardDirectoryReader$1.doBody (StandardDirectoryReader.java:77)</span><br><span class="line">  [8] org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run (SegmentInfos.java:809)</span><br><span class="line">  [9] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:109)</span><br><span class="line">  [10] org.apache.lucene.index.StandardDirectoryReader.open (StandardDirectoryReader.java:67)</span><br><span class="line">  [11] org.apache.lucene.index.DirectoryReader.open (DirectoryReader.java:60)</span><br><span class="line">  [12] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:105)</span><br></pre></td></tr></table></figure>


<h3 id="加载doc的内容到Document-对象"><a href="#加载doc的内容到Document-对象" class="headerlink" title="加载doc的内容到Document 对象"></a>加载doc的内容到Document 对象</h3><p>整个流程是通过docid 获取document 的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void visitDocument(int docID, StoredFieldVisitor visitor) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">  final SerializedDocument doc = document(docID);  // 通过docID 获取doc对象</span><br><span class="line"></span><br><span class="line">  for (int fieldIDX = 0; fieldIDX &lt; doc.numStoredFields; fieldIDX++) &#123;</span><br><span class="line">    final long infoAndBits = doc.in.readVLong();</span><br><span class="line">    final int fieldNumber = (int) (infoAndBits &gt;&gt;&gt; TYPE_BITS);</span><br><span class="line">    final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldNumber);</span><br><span class="line"></span><br><span class="line">    final int bits = (int) (infoAndBits &amp; TYPE_MASK);</span><br><span class="line">    assert bits &lt;= NUMERIC_DOUBLE : &quot;bits=&quot; + Integer.toHexString(bits);</span><br><span class="line"></span><br><span class="line">    switch (visitor.needsField(fieldInfo)) &#123;</span><br><span class="line">      case YES:</span><br><span class="line">        readField(doc.in, visitor, fieldInfo, bits);   // 通过input , 也就是input 绑定的fd ,去读mmap64 映射的文件 ,在这里会读取后缀名为 .fdt 的文件 </span><br><span class="line">        break;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.document.Document.add (Document.java:60)</span><br><span class="line">  [2] org.apache.lucene.document.DocumentStoredFieldVisitor.stringField (DocumentStoredFieldVisitor.java:74)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.readField (Lucene90CompressingStoredFieldsReader.java:246)</span><br><span class="line">  [4] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.visitDocument (Lucene90CompressingStoredFieldsReader.java:640)</span><br><span class="line">  [5] org.apache.lucene.index.CodecReader.document (CodecReader.java:89)</span><br><span class="line">  [6] org.apache.lucene.index.BaseCompositeReader.document (BaseCompositeReader.java:154)</span><br><span class="line">  [7] org.apache.lucene.index.IndexReader.document (IndexReader.java:380)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.doc (IndexSearcher.java:380)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:214)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="通过docid-构建-SerializedDocument"><a href="#通过docid-构建-SerializedDocument" class="headerlink" title="通过docid 构建 SerializedDocument"></a>通过docid 构建 SerializedDocument</h3><p>首先入口在这里: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.document</span><br></pre></td></tr></table></figure>
<p>Lucene90CompressingStoredFieldsReader的document 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.store.ByteBufferIndexInput$SingleBufferImpl.seek (ByteBufferIndexInput.java:529)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.document (Lucene90CompressingStoredFieldsReader.java:606)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.visitDocument (Lucene90CompressingStoredFieldsReader.java:628)</span><br><span class="line">  [4] org.apache.lucene.index.CodecReader.document (CodecReader.java:89)</span><br><span class="line">  [5] org.apache.lucene.index.BaseCompositeReader.document (BaseCompositeReader.java:154)</span><br><span class="line">  [6] org.apache.lucene.index.IndexReader.document (IndexReader.java:380)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.doc (IndexSearcher.java:380)</span><br><span class="line">  [8] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:214)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SerializedDocument document(int docID) throws IOException &#123;</span><br><span class="line">  if (state.contains(docID) == false) &#123;</span><br><span class="line">    fieldsStream.seek(indexReader.getStartPointer(docID)); // 通过mmap64 偏移</span><br><span class="line">    state.reset(docID);</span><br><span class="line">  &#125;</span><br><span class="line">  assert state.contains(docID);</span><br><span class="line">  return state.document(docID);    // 再看具体的实现 , 这个state 对象对应的类是一个静态内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看看静态内部类的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * Get the serialized representation of the given docID. This docID has to be contained in the</span><br><span class="line">   * current block.</span><br><span class="line">   */</span><br><span class="line">  SerializedDocument document(int docID) throws IOException &#123;</span><br><span class="line">    if (contains(docID) == false) &#123;</span><br><span class="line">      throw new IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int index = docID - docBase;   </span><br><span class="line">    final int offset = Math.toIntExact(offsets[index]);</span><br><span class="line">    final int length = Math.toIntExact(offsets[index + 1]) - offset;</span><br><span class="line">    final int totalLength = Math.toIntExact(offsets[chunkDocs]);</span><br><span class="line">    final int numStoredFields = Math.toIntExact(this.numStoredFields[index]);</span><br><span class="line"></span><br><span class="line">    final BytesRef bytes;</span><br><span class="line">    if (merging) &#123;</span><br><span class="line">      bytes = this.bytes;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      bytes = new BytesRef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final DataInput documentInput;</span><br><span class="line">    if (length == 0) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      fieldsStream.seek(startPointer);  // seek mmap64 偏移量获取文件</span><br><span class="line">      decompressor.decompress(fieldsStream, totalLength, offset, length, bytes); // 解压对应的数据  </span><br><span class="line">      assert bytes.length == length;</span><br><span class="line">      documentInput = new ByteArrayDataInput(bytes.bytes, bytes.offset, bytes.length);  // 将数据塞入bytes</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new SerializedDocument(documentInput, length, numStoredFields);  // 构建SerializedDocument</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面具体描述加载内容的过程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> pos = 4</span><br><span class="line">main[1] dump bytes</span><br><span class="line"> bytes = &#123;</span><br><span class="line">120, 116, 0, 26, 47, 104, 111, 109, 101, 47, 117, 98, 117, 110, 116, 117, 47, 100, 111, 99, 47, 104, 101, 108, 108, 111, 46, 116, 120, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main[1] print in</span><br><span class="line"> in = &quot;MMapIndexInput(path=&quot;/home/ubuntu/index/_j.fdt&quot;)&quot;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.LZ4WithPresetDictCompressionMode$LZ4WithPresetDictDecompressor.decompress (LZ4WithPresetDictCompressionMode.java:88)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader$BlockState.document (Lucene90CompressingStoredFieldsReader.java:595)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.document (Lucene90CompressingStoredFieldsReader.java:610)</span><br><span class="line">  [4] org.apache.lucene.codecs.lucene90.compressing.Lucene90CompressingStoredFieldsReader.visitDocument (Lucene90CompressingStoredFieldsReader.java:628)</span><br><span class="line">  [5] org.apache.lucene.index.CodecReader.document (CodecReader.java:89)</span><br><span class="line">  [6] org.apache.lucene.index.BaseCompositeReader.document (BaseCompositeReader.java:154)</span><br><span class="line">  [7] org.apache.lucene.index.IndexReader.document (IndexReader.java:380)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.doc (IndexSearcher.java:380)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:214)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="term-文件的加载和处理"><a href="#term-文件的加载和处理" class="headerlink" title="term 文件的加载和处理"></a>term 文件的加载和处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public SegmentTermsEnum(FieldReader fr) throws IOException &#123;</span><br><span class="line">   this.fr = fr;</span><br><span class="line"></span><br><span class="line">   // if (DEBUG) &#123;</span><br><span class="line">   //   System.out.println(&quot;BTTR.init seg=&quot; + fr.parent.segment);</span><br><span class="line">   // &#125;</span><br><span class="line">   stack = new SegmentTermsEnumFrame[0];</span><br><span class="line"></span><br><span class="line">   // Used to hold seek by TermState, or cached seek</span><br><span class="line">   staticFrame = new SegmentTermsEnumFrame(this, -1);</span><br><span class="line"></span><br><span class="line">   if (fr.index == null) &#123;</span><br><span class="line">     fstReader = null;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     fstReader = fr.index.getBytesReader();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Init w/ root block; don&#x27;t use index since it may</span><br><span class="line">   // not (and need not) have been loaded</span><br><span class="line">   for (int arcIdx = 0; arcIdx &lt; arcs.length; arcIdx++) &#123;</span><br><span class="line">     arcs[arcIdx] = new FST.Arc&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   currentFrame = staticFrame;</span><br><span class="line">   final FST.Arc&lt;BytesRef&gt; arc;</span><br><span class="line">   if (fr.index != null) &#123;</span><br><span class="line">     arc = fr.index.getFirstArc(arcs[0]);</span><br><span class="line">     // Empty string prefix must have an output in the index!</span><br><span class="line">     assert arc.isFinal();</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     arc = null;</span><br><span class="line">   &#125;</span><br><span class="line">   // currentFrame = pushFrame(arc, rootCode, 0);</span><br><span class="line">   // currentFrame.loadBlock();</span><br><span class="line">   validIndexPrefix = 0;</span><br><span class="line">   // if (DEBUG) &#123;</span><br><span class="line">   //   System.out.println(&quot;init frame state &quot; + currentFrame.ord);</span><br><span class="line">   //   printSeekState();</span><br><span class="line">   // &#125;</span><br><span class="line"></span><br><span class="line">   // System.out.println();</span><br><span class="line">   // computeBlockStats().print(System.out);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>解析获取getArc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private FST.Arc&lt;BytesRef&gt; getArc(int ord) &#123;</span><br><span class="line">  if (ord &gt;= arcs.length) &#123;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class="line">    final FST.Arc&lt;BytesRef&gt;[] next =</span><br><span class="line">        new FST.Arc[ArrayUtil.oversize(1 + ord, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];</span><br><span class="line">    System.arraycopy(arcs, 0, next, 0, arcs.length);</span><br><span class="line">    for (int arcOrd = arcs.length; arcOrd &lt; next.length; arcOrd++) &#123;</span><br><span class="line">      next[arcOrd] = new FST.Arc&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    arcs = next;</span><br><span class="line">  &#125;</span><br><span class="line">  return arcs[ord];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hit: &quot;thread=main&quot;, org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.getArc(), line=222 bci=0</span><br><span class="line">222        if (ord &gt;= arcs.length) &#123;</span><br><span class="line"></span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.getArc (SegmentTermsEnum.java:222)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.seekExact (SegmentTermsEnum.java:511)</span><br><span class="line">  [3] org.apache.lucene.index.TermStates.loadTermsEnum (TermStates.java:117)</span><br><span class="line">  [4] org.apache.lucene.index.TermStates.build (TermStates.java:102)</span><br><span class="line">  [5] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="获取所有的数据"><a href="#获取所有的数据" class="headerlink" title="获取所有的数据"></a>获取所有的数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.Weight$DefaultBulkScorer.scoreAll (Weight.java:300)</span><br><span class="line">  [2] org.apache.lucene.search.Weight$DefaultBulkScorer.score (Weight.java:247)</span><br><span class="line">  [3] org.apache.lucene.search.BulkScorer.score (BulkScorer.java:38)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:770)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line">main[1] list</span><br><span class="line">296            DocIdSetIterator iterator,</span><br><span class="line">297            TwoPhaseIterator twoPhase,</span><br><span class="line">298            Bits acceptDocs)</span><br><span class="line">299            throws IOException &#123;</span><br><span class="line">300 =&gt;       if (twoPhase == null) &#123;</span><br><span class="line">301            for (int doc = iterator.nextDoc();</span><br><span class="line">302                doc != DocIdSetIterator.NO_MORE_DOCS;</span><br><span class="line">303                doc = iterator.nextDoc()) &#123;</span><br><span class="line">304              if (acceptDocs == null || acceptDocs.get(doc)) &#123;</span><br><span class="line">305                collector.collect(doc);</span><br><span class="line">main[1] print iterator</span><br><span class="line"> iterator = &quot;org.apache.lucene.search.ImpactsDISI@6279cee3&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">494        @Override</span><br><span class="line">495        public int advance(int target) throws IOException &#123;</span><br><span class="line">496          // current skip docID &lt; docIDs generated from current buffer &lt;= next skip docID</span><br><span class="line">497          // we don&#x27;t need to skip if target is buffered already</span><br><span class="line">498 =&gt;       if (docFreq &gt; BLOCK_SIZE &amp;&amp; target &gt; nextSkipDoc) &#123;</span><br><span class="line">499    </span><br><span class="line">500            if (skipper == null) &#123;</span><br><span class="line">501              // Lazy init: first time this enum has ever been used for skipping</span><br><span class="line">502              skipper =</span><br><span class="line">503                  new Lucene90SkipReader(</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.Lucene90PostingsReader$BlockDocsEnum.advance (Lucene90PostingsReader.java:498)</span><br><span class="line">  [2] org.apache.lucene.index.SlowImpactsEnum.advance (SlowImpactsEnum.java:77)</span><br><span class="line">  [3] org.apache.lucene.search.ImpactsDISI.advance (ImpactsDISI.java:135)</span><br><span class="line">  [4] org.apache.lucene.search.ImpactsDISI.nextDoc (ImpactsDISI.java:140)</span><br><span class="line">  [5] org.apache.lucene.search.Weight$DefaultBulkScorer.scoreAll (Weight.java:301)</span><br><span class="line">  [6] org.apache.lucene.search.Weight$DefaultBulkScorer.score (Weight.java:247)</span><br><span class="line">  [7] org.apache.lucene.search.BulkScorer.score (BulkScorer.java:38)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:770)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [10] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [11] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [12] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [13] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [14] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>


<p>生成iterator 的相关类 , 对应的是SegmentTermsEnum</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.TermQuery$TermWeight.getTermsEnum (TermQuery.java:145)</span><br><span class="line">  [2] org.apache.lucene.search.TermQuery$TermWeight.scorer (TermQuery.java:107)</span><br><span class="line">  [3] org.apache.lucene.search.Weight.bulkScorer (Weight.java:166)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:767)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line">main[1] print termsEnum</span><br><span class="line"> termsEnum = &quot;org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum@1a84f40f&quot;</span><br></pre></td></tr></table></figure>

<p><code>getTermsEnum</code> 方法能拿到term的统计位置偏移,SegmentTermsEnum 不包含dociterator</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.index.Term.bytes (Term.java:128)</span><br><span class="line">  [2] org.apache.lucene.search.TermQuery$TermWeight.getTermsEnum (TermQuery.java:145)</span><br><span class="line">  [3] org.apache.lucene.search.TermQuery$TermWeight.scorer (TermQuery.java:107)</span><br><span class="line">  [4] org.apache.lucene.search.Weight.bulkScorer (Weight.java:166)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:767)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">144          final TermsEnum termsEnum = context.reader().terms(term.field()).iterator();</span><br><span class="line">145 =&gt;       termsEnum.seekExact(term.bytes(), state);</span><br><span class="line">146          return termsEnum;</span><br><span class="line">147        &#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>term.bytes()</code> 就是我们的搜索值 , 所以term对应的倒排信息是从这里开始读的(还没看完,暂时那么定)</p>
<p>读出倒排信息之后,开始排序.<br>score 有iteration 可以遍历所有doc_id </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">348        // (needsFreq=false)</span><br><span class="line">349        private boolean isFreqsRead;</span><br><span class="line">350        private int singletonDocID; // docid when there is a single pulsed posting, otherwise -1</span><br><span class="line">351    </span><br><span class="line">352 =&gt;     public BlockDocsEnum(FieldInfo fieldInfo) throws IOException &#123;</span><br><span class="line">353          this.startDocIn = Lucene90PostingsReader.this.docIn;</span><br><span class="line">354          this.docIn = null;</span><br><span class="line">355          indexHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) &gt;= 0;</span><br><span class="line">356          indexHasPos =</span><br><span class="line">357              fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) &gt;= 0;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.Lucene90PostingsReader$BlockDocsEnum.&lt;init&gt; (Lucene90PostingsReader.java:352)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.Lucene90PostingsReader.postings (Lucene90PostingsReader.java:258)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.Lucene90PostingsReader.impacts (Lucene90PostingsReader.java:280)</span><br><span class="line">  [4] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.impacts (SegmentTermsEnum.java:1,150)</span><br><span class="line">  [5] org.apache.lucene.search.TermQuery$TermWeight.scorer (TermQuery.java:114)</span><br><span class="line">  [6] org.apache.lucene.search.Weight.bulkScorer (Weight.java:166)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:767)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [10] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [11] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [12] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [13] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>

<h3 id="topk-collector的堆栈"><a href="#topk-collector的堆栈" class="headerlink" title="topk collector的堆栈"></a>topk collector的堆栈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hit: &quot;thread=main&quot;, org.apache.lucene.search.TopDocsCollector.populateResults(), line=64 bci=0</span><br><span class="line">64        for (int i = howMany - 1; i &gt;= 0; i--) &#123;</span><br><span class="line"></span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.TopDocsCollector.populateResults (TopDocsCollector.java:64)</span><br><span class="line">  [2] org.apache.lucene.search.TopDocsCollector.topDocs (TopDocsCollector.java:166)</span><br><span class="line">  [3] org.apache.lucene.search.TopDocsCollector.topDocs (TopDocsCollector.java:98)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher$2.reduce (IndexSearcher.java:526)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher$2.reduce (IndexSearcher.java:505)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:694)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line">main[1]</span><br></pre></td></tr></table></figure>

<h3 id="search-过程"><a href="#search-过程" class="headerlink" title="search 过程"></a>search 过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main[1] dump collector</span><br><span class="line"> collector = &#123;</span><br><span class="line">    org.apache.lucene.search.TopScoreDocCollector.docBase: 0</span><br><span class="line">    org.apache.lucene.search.TopScoreDocCollector.pqTop: instance of org.apache.lucene.search.ScoreDoc(id=1529)</span><br><span class="line">    org.apache.lucene.search.TopScoreDocCollector.hitsThresholdChecker: instance of org.apache.lucene.search.HitsThresholdChecker$LocalHitsThresholdChecker(id=1530)</span><br><span class="line">    org.apache.lucene.search.TopScoreDocCollector.minScoreAcc: null</span><br><span class="line">    org.apache.lucene.search.TopScoreDocCollector.minCompetitiveScore: 0.0</span><br><span class="line">    org.apache.lucene.search.TopScoreDocCollector.$assertionsDisabled: true</span><br><span class="line">    org.apache.lucene.search.TopDocsCollector.EMPTY_TOPDOCS: instance of org.apache.lucene.search.TopDocs(id=1531)</span><br><span class="line">    org.apache.lucene.search.TopDocsCollector.pq: instance of org.apache.lucene.search.HitQueue(id=1532)</span><br><span class="line">    org.apache.lucene.search.TopDocsCollector.totalHits: 0</span><br><span class="line">    org.apache.lucene.search.TopDocsCollector.totalHitsRelation: instance of org.apache.lucene.search.TotalHits$Relation(id=1533)</span><br><span class="line">&#125;</span><br><span class="line">main[1] print collector</span><br><span class="line"> collector = &quot;org.apache.lucene.search.TopScoreDocCollector$SimpleTopScoreDocCollector@62bd765&quot;</span><br></pre></td></tr></table></figure>


<h3 id="获取hits-数量的过程"><a href="#获取hits-数量的过程" class="headerlink" title="获取hits 数量的过程"></a>获取hits 数量的过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">690      private &lt;C extends Collector, T&gt; T search(</span><br><span class="line">691          Weight weight, CollectorManager&lt;C, T&gt; collectorManager, C firstCollector) throws IOException &#123;</span><br><span class="line">692        if (executor == null || leafSlices.length &lt;= 1) &#123;</span><br><span class="line">693          search(leafContexts, weight, firstCollector);</span><br><span class="line">694 =&gt;       return collectorManager.reduce(Collections.singletonList(firstCollector));</span><br><span class="line">695        &#125; else &#123;</span><br><span class="line">696          final List&lt;C&gt; collectors = new ArrayList&lt;&gt;(leafSlices.length);</span><br><span class="line">697          collectors.add(firstCollector);</span><br><span class="line">698          final ScoreMode scoreMode = firstCollector.scoreMode();</span><br><span class="line">699          for (int i = 1; i &lt; leafSlices.length; ++i) &#123;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:694)</span><br><span class="line">  [2] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [3] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [5] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [6] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>

<p>在<code>org.apache.lucene.search.TopScoreDocCollector.create</code>  , 一直往上翻,发现<code>org.apache.lucene.search.IndexSearcher.searchAfter</code> 就已经有了.<br>那么这个hit数量是从哪里初始化的呢?</p>
<p>很明显,search会填充firstCollector的数据,那么是在哪里赋值的呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected void search(List&lt;LeafReaderContext&gt; leaves, Weight weight, Collector collector)</span><br><span class="line">     throws IOException &#123;</span><br><span class="line"></span><br><span class="line">   // TODO: should we make this</span><br><span class="line">   // threaded...? the Collector could be sync&#x27;d?</span><br><span class="line">   // always use single thread:</span><br><span class="line">   for (LeafReaderContext ctx : leaves) &#123; // search each subreader</span><br><span class="line">     final LeafCollector leafCollector;</span><br><span class="line">     try &#123;</span><br><span class="line">       leafCollector = collector.getLeafCollector(ctx);</span><br><span class="line">     &#125; catch (</span><br><span class="line">         @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">         CollectionTerminatedException e) &#123;</span><br><span class="line">       // there is no doc of interest in this reader context</span><br><span class="line">       // continue with the following leaf</span><br><span class="line">       continue;</span><br><span class="line">     &#125;</span><br><span class="line">     BulkScorer scorer = weight.bulkScorer(ctx);      /// 在这里会获取total hits</span><br><span class="line">     if (scorer != null) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">         scorer.score(leafCollector, ctx.reader().getLiveDocs());</span><br><span class="line">       &#125; catch (</span><br><span class="line">           @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">           CollectionTerminatedException e) &#123;</span><br><span class="line">         // collection was terminated prematurely</span><br><span class="line">         // continue with the following leaf</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>看完最后的堆栈,我们确定了totalHits 是在这里赋值的 , 也就是只要调用了一次就自增一, 很明显这是一个统计,那么这个统计就是命中的搜索内容,那么搜索内容是怎么来的呢?</p>
<p>我们只能往上追溯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.TopScoreDocCollector$SimpleTopScoreDocCollector$1.collect (TopScoreDocCollector.java:73)</span><br><span class="line">  [2] org.apache.lucene.search.Weight$DefaultBulkScorer.scoreAll (Weight.java:305)</span><br><span class="line">  [3] org.apache.lucene.search.Weight$DefaultBulkScorer.score (Weight.java:247)</span><br><span class="line">  [4] org.apache.lucene.search.BulkScorer.score (BulkScorer.java:38)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:770)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void collect(int doc) throws IOException &#123;</span><br><span class="line">          float score = scorer.score();   // 计算分数 , 也是回调专用的score 函数 , 插件化</span><br><span class="line"></span><br><span class="line">          // This collector relies on the fact that scorers produce positive values:</span><br><span class="line">          assert score &gt;= 0; // NOTE: false for NaN</span><br><span class="line"></span><br><span class="line">          totalHits++;                 // hit +1 在这里触发</span><br><span class="line">          hitsThresholdChecker.incrementHitCount();</span><br><span class="line"></span><br><span class="line">          if (minScoreAcc != null &amp;&amp; (totalHits &amp; minScoreAcc.modInterval) == 0) &#123;</span><br><span class="line">            updateGlobalMinCompetitiveScore(scorer);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (score &lt;= pqTop.score) &#123;</span><br><span class="line">            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) &#123;</span><br><span class="line">              // we just reached totalHitsThreshold, we can start setting the min</span><br><span class="line">              // competitive score now</span><br><span class="line">              updateMinCompetitiveScore(scorer);</span><br><span class="line">            &#125;</span><br><span class="line">            // Since docs are returned in-order (i.e., increasing doc Id), a document</span><br><span class="line">            // with equal score to pqTop.score cannot compete since HitQueue favors</span><br><span class="line">            // documents with lower doc Ids. Therefore reject those docs too.</span><br><span class="line">            return;</span><br><span class="line">          &#125;</span><br><span class="line">          pqTop.doc = doc + docBase;</span><br><span class="line">          pqTop.score = score;</span><br><span class="line">          pqTop = pq.updateTop();</span><br><span class="line">          updateMinCompetitiveScore(scorer);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>


<p>继续往上面推之后,我们找到了堆栈,scorer 是根据context生成的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Optional method, to return a &#123;@link BulkScorer&#125; to score the query and send hits to a &#123;@link</span><br><span class="line"> * Collector&#125;. Only queries that have a different top-level approach need to override this; the</span><br><span class="line"> * default implementation pulls a normal &#123;@link Scorer&#125; and iterates and collects the resulting</span><br><span class="line"> * hits which are not marked as deleted.</span><br><span class="line"> *</span><br><span class="line"> * @param context the &#123;@link org.apache.lucene.index.LeafReaderContext&#125; for which to return the</span><br><span class="line"> *     &#123;@link Scorer&#125;.</span><br><span class="line"> * @return a &#123;@link BulkScorer&#125; which scores documents and passes them to a collector.</span><br><span class="line"> * @throws IOException if there is a low-level I/O error</span><br><span class="line"> */</span><br><span class="line">public BulkScorer bulkScorer(LeafReaderContext context) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">  Scorer scorer = scorer(context);</span><br><span class="line">  if (scorer == null) &#123;</span><br><span class="line">    // No docs match</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // This impl always scores docs in order, so we can</span><br><span class="line">  // ignore scoreDocsInOrder:</span><br><span class="line">  return new DefaultBulkScorer(scorer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再往上看:   刚刚看到了bulkScorer 回调了一个<code>scorer</code> 方法,这个<code>scorer</code>抽象方法的实现是在<code>org.apache.lucene.search.TermQuery$TermWeight.scorer</code></p>
<p>这个scorer方法根据入参<code>context</code> 以及外部类<code>termQuery.term</code>计算htis命中的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">103          assert termStates == null || termStates.wasBuiltFor(ReaderUtil.getTopLevelContext(context))</span><br><span class="line">104              : &quot;The top-reader used to create Weight is not the same as the current reader&#x27;s top-reader (&quot;</span><br><span class="line">105                  + ReaderUtil.getTopLevelContext(context);</span><br><span class="line">106          ;</span><br><span class="line">107 =&gt;       final TermsEnum termsEnum = getTermsEnum(context);</span><br><span class="line">108          if (termsEnum == null) &#123;</span><br><span class="line">109            return null;</span><br><span class="line">110          &#125;</span><br><span class="line">111          LeafSimScorer scorer =</span><br><span class="line">112              new LeafSimScorer(simScorer, context.reader(), term.field(), scoreMode.needsScores());    // 这里term是外部类的term ,也就是this$0.term</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.search.TermQuery$TermWeight.scorer (TermQuery.java:107)</span><br><span class="line">  [2] org.apache.lucene.search.Weight.bulkScorer (Weight.java:166)</span><br><span class="line">  [3] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:767)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:693)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:687)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [8] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>
<p>所以之后会调用advance,最后调用的是下面这个advance方法, 这里会用到docTermStartFP , 那么这个遍历在哪里初始化? </p>
<p>其实是在termStates里面获取,初始化的地方在<code>docTermStartFP = termState.docStartFP;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">lucene\core\src\java\org\apache\lucene\codecs\lucene90\Lucene90PostingsReader.java</span><br><span class="line">    @Override</span><br><span class="line">    public int advance(int target) throws IOException &#123;</span><br><span class="line">      // current skip docID &lt; docIDs generated from current buffer &lt;= next skip docID</span><br><span class="line">      // we don&#x27;t need to skip if target is buffered already</span><br><span class="line">      if (docFreq &gt; BLOCK_SIZE &amp;&amp; target &gt; nextSkipDoc) &#123;</span><br><span class="line"></span><br><span class="line">        if (skipper == null) &#123;</span><br><span class="line">          // Lazy init: first time this enum has ever been used for skipping</span><br><span class="line">          skipper =</span><br><span class="line">              new Lucene90SkipReader(</span><br><span class="line">                  docIn.clone(), MAX_SKIP_LEVELS, indexHasPos, indexHasOffsets, indexHasPayloads);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!skipped) &#123;</span><br><span class="line">          assert skipOffset != -1;</span><br><span class="line">          // This is the first time this enum has skipped</span><br><span class="line">          // since reset() was called; load the skip data:</span><br><span class="line">          skipper.init(docTermStartFP + skipOffset, docTermStartFP, 0, 0, docFreq);</span><br><span class="line">          skipped = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // always plus one to fix the result, since skip position in Lucene90SkipReader</span><br><span class="line">        // is a little different from MultiLevelSkipListReader</span><br><span class="line">        final int newDocUpto = skipper.skipTo(target) + 1;</span><br><span class="line"></span><br><span class="line">        if (newDocUpto &gt;= blockUpto) &#123;</span><br><span class="line">          // Skipper moved</span><br><span class="line">          assert newDocUpto % BLOCK_SIZE == 0 : &quot;got &quot; + newDocUpto;</span><br><span class="line">          blockUpto = newDocUpto;</span><br><span class="line"></span><br><span class="line">          // Force to read next block</span><br><span class="line">          docBufferUpto = BLOCK_SIZE;</span><br><span class="line">          accum = skipper.getDoc(); // actually, this is just lastSkipEntry</span><br><span class="line">          docIn.seek(skipper.getDocPointer()); // now point to the block we want to search</span><br><span class="line">          // even if freqBuffer were not read from the previous block, we will mark them as read,</span><br><span class="line">          // as we don&#x27;t need to skip the previous block freqBuffer in refillDocs,</span><br><span class="line">          // as we have already positioned docIn where in needs to be.</span><br><span class="line">          isFreqsRead = true;</span><br><span class="line">        &#125;</span><br><span class="line">        // next time we call advance, this is used to</span><br><span class="line">        // foresee whether skipper is necessary.</span><br><span class="line">        nextSkipDoc = skipper.getNextSkipDoc();</span><br><span class="line">      &#125;</span><br><span class="line">      if (docBufferUpto == BLOCK_SIZE) &#123;</span><br><span class="line">        refillDocs();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Now scan... this is an inlined/pared down version</span><br><span class="line">      // of nextDoc():</span><br><span class="line">      long doc;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        doc = docBuffer[docBufferUpto];</span><br><span class="line"></span><br><span class="line">        if (doc &gt;= target) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        ++docBufferUpto;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      docBufferUpto++;</span><br><span class="line">      return this.doc = (int) doc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long cost() &#123;</span><br><span class="line">      return docFreq;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>那么我们继续看termStates是怎么初始化的? 我先猜测term会是termStates 的一个成员变量</p>
<p>通过断点,我们最后找到了下面这个:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">178      &#125;</span><br><span class="line">179    </span><br><span class="line">180      @Override</span><br><span class="line">181      public BlockTermState newTermState() &#123;</span><br><span class="line">182 =&gt;     return new IntBlockTermState();</span><br><span class="line">183      &#125;</span><br><span class="line">184    </span><br><span class="line">185      @Override</span><br><span class="line">186      public void close() throws IOException &#123;</span><br><span class="line">187        IOUtils.close(docIn, posIn, payIn);</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.Lucene90PostingsReader.newTermState (Lucene90PostingsReader.java:182)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnumFrame.&lt;init&gt; (SegmentTermsEnumFrame.java:101)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.&lt;init&gt; (SegmentTermsEnum.java:76)</span><br><span class="line">  [4] org.apache.lucene.codecs.lucene90.blocktree.FieldReader.iterator (FieldReader.java:153)</span><br><span class="line">  [5] org.apache.lucene.index.TermStates.loadTermsEnum (TermStates.java:116)</span><br><span class="line">  [6] org.apache.lucene.index.TermStates.build (TermStates.java:102)</span><br><span class="line">  [7] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [10] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [11] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [12] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [13] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line">main[1]</span><br></pre></td></tr></table></figure>


<p>最后这里应该就是最最核心的获取词的流程了,i hope so</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">113    </span><br><span class="line">114      private static TermsEnum loadTermsEnum(LeafReaderContext ctx, Term term) throws IOException &#123;</span><br><span class="line">115        final Terms terms = Terms.getTerms(ctx.reader(), term.field());</span><br><span class="line">116        final TermsEnum termsEnum = terms.iterator();</span><br><span class="line">117 =&gt;     if (termsEnum.seekExact(term.bytes())) &#123;</span><br><span class="line">118          return termsEnum;</span><br><span class="line">119        &#125;</span><br><span class="line">120        return null;</span><br><span class="line">121      &#125;</span><br><span class="line">122    </span><br><span class="line">main[1] print term.bytes()</span><br><span class="line"> term.bytes() = &quot;[61 6d]&quot;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.index.TermStates.loadTermsEnum (TermStates.java:117)</span><br><span class="line">  [2] org.apache.lucene.index.TermStates.build (TermStates.java:102)</span><br><span class="line">  [3] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [8] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>


<p>最后的最后应该是调用这里: 获取所有的term的个数,具体是哪里还需要判断,但是路径应该就是这里了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line">// Target&#x27;s prefix matches this block&#x27;s prefix; we</span><br><span class="line">// scan the entries check if the suffix matches.</span><br><span class="line">public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">  // if (DEBUG) System.out.println(&quot;    scanToTermLeaf: block fp=&quot; + fp + &quot; prefix=&quot; + prefix + &quot;</span><br><span class="line">  // nextEnt=&quot; + nextEnt + &quot; (of &quot; + entCount + &quot;) target=&quot; + brToString(target) + &quot; term=&quot; +</span><br><span class="line">  // brToString(term));</span><br><span class="line"></span><br><span class="line">  assert nextEnt != -1;</span><br><span class="line"></span><br><span class="line">  ste.termExists = true;</span><br><span class="line">  subCode = 0;</span><br><span class="line"></span><br><span class="line">  if (nextEnt == entCount) &#123;</span><br><span class="line">    if (exactOnly) &#123;</span><br><span class="line">      fillTerm();</span><br><span class="line">    &#125;</span><br><span class="line">    return SeekStatus.END;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert prefixMatches(target);</span><br><span class="line"></span><br><span class="line">  // TODO: binary search when all terms have the same length, which is common for ID fields,</span><br><span class="line">  // which are also the most sensitive to lookup performance?</span><br><span class="line">  // Loop over each entry (term or sub-block) in this block:</span><br><span class="line">  do &#123;</span><br><span class="line">    nextEnt++;</span><br><span class="line"></span><br><span class="line">    suffix = suffixLengthsReader.readVInt();</span><br><span class="line"></span><br><span class="line">    // if (DEBUG) &#123;</span><br><span class="line">    //   BytesRef suffixBytesRef = new BytesRef();</span><br><span class="line">    //   suffixBytesRef.bytes = suffixBytes;</span><br><span class="line">    //   suffixBytesRef.offset = suffixesReader.getPosition();</span><br><span class="line">    //   suffixBytesRef.length = suffix;</span><br><span class="line">    //   System.out.println(&quot;      cycle: term &quot; + (nextEnt-1) + &quot; (of &quot; + entCount + &quot;) suffix=&quot;</span><br><span class="line">    // + brToString(suffixBytesRef));</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    startBytePos = suffixesReader.getPosition();</span><br><span class="line">    suffixesReader.skipBytes(suffix);</span><br><span class="line"></span><br><span class="line">    // Loop over bytes in the suffix, comparing to the target</span><br><span class="line">    final int cmp =</span><br><span class="line">        Arrays.compareUnsigned(</span><br><span class="line">            suffixBytes,</span><br><span class="line">            startBytePos,</span><br><span class="line">            startBytePos + suffix,</span><br><span class="line">            target.bytes,</span><br><span class="line">            target.offset + prefix,</span><br><span class="line">            target.offset + target.length);</span><br><span class="line"></span><br><span class="line">    if (cmp &lt; 0) &#123;</span><br><span class="line">      // Current entry is still before the target;</span><br><span class="line">      // keep scanning</span><br><span class="line">    &#125; else if (cmp &gt; 0) &#123;</span><br><span class="line">      // Done!  Current entry is after target --</span><br><span class="line">      // return NOT_FOUND:</span><br><span class="line">      fillTerm();</span><br><span class="line"></span><br><span class="line">      // if (DEBUG) System.out.println(&quot;        not found&quot;);</span><br><span class="line">      return SeekStatus.NOT_FOUND;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Exact match!</span><br><span class="line"></span><br><span class="line">      // This cannot be a sub-block because we</span><br><span class="line">      // would have followed the index to this</span><br><span class="line">      // sub-block from the start:</span><br><span class="line"></span><br><span class="line">      assert ste.termExists;</span><br><span class="line">      fillTerm();</span><br><span class="line">      // if (DEBUG) System.out.println(&quot;        found!&quot;);</span><br><span class="line">      return SeekStatus.FOUND;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; while (nextEnt &lt; entCount);</span><br><span class="line"></span><br><span class="line">  // It is possible (and OK) that terms index pointed us</span><br><span class="line">  // at this block, but, we scanned the entire block and</span><br><span class="line">  // did not find the term to position to.  This happens</span><br><span class="line">  // when the target is after the last term in the block</span><br><span class="line">  // (but, before the next term in the index).  EG</span><br><span class="line">  // target could be foozzz, and terms index pointed us</span><br><span class="line">  // to the foo* block, but the last term in this block</span><br><span class="line">  // was fooz (and, eg, first term in the next block will</span><br><span class="line">  // bee fop).</span><br><span class="line">  // if (DEBUG) System.out.println(&quot;      block end&quot;);</span><br><span class="line">  if (exactOnly) &#123;</span><br><span class="line">    fillTerm();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // TODO: not consistent that in the</span><br><span class="line">  // not-exact case we don&#x27;t next() into the next</span><br><span class="line">  // frame here</span><br><span class="line">  return SeekStatus.END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Target&#x27;s prefix matches this block&#x27;s prefix; we</span><br><span class="line">// scan the entries check if the suffix matches.</span><br><span class="line">public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">  // if (DEBUG) System.out.println(&quot;    scanToTermNonLeaf: block fp=&quot; + fp + &quot; prefix=&quot; + prefix +</span><br><span class="line">  // &quot; nextEnt=&quot; + nextEnt + &quot; (of &quot; + entCount + &quot;) target=&quot; + brToString(target) + &quot; term=&quot; +</span><br><span class="line">  // brToString(target));</span><br><span class="line"></span><br><span class="line">  assert nextEnt != -1;</span><br><span class="line"></span><br><span class="line">  if (nextEnt == entCount) &#123;</span><br><span class="line">    if (exactOnly) &#123;</span><br><span class="line">      fillTerm();</span><br><span class="line">      ste.termExists = subCode == 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return SeekStatus.END;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert prefixMatches(target);</span><br><span class="line"></span><br><span class="line">  // Loop over each entry (term or sub-block) in this block:</span><br><span class="line">  while (nextEnt &lt; entCount) &#123;</span><br><span class="line"></span><br><span class="line">    nextEnt++;</span><br><span class="line"></span><br><span class="line">    final int code = suffixLengthsReader.readVInt();</span><br><span class="line">    suffix = code &gt;&gt;&gt; 1;</span><br><span class="line"></span><br><span class="line">    // if (DEBUG) &#123;</span><br><span class="line">    //  BytesRef suffixBytesRef = new BytesRef();</span><br><span class="line">    //  suffixBytesRef.bytes = suffixBytes;</span><br><span class="line">    //  suffixBytesRef.offset = suffixesReader.getPosition();</span><br><span class="line">    //  suffixBytesRef.length = suffix;</span><br><span class="line">    //  System.out.println(&quot;      cycle: &quot; + ((code&amp;1)==1 ? &quot;sub-block&quot; : &quot;term&quot;) + &quot; &quot; +</span><br><span class="line">    // (nextEnt-1) + &quot; (of &quot; + entCount + &quot;) suffix=&quot; + brToString(suffixBytesRef));</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    final int termLen = prefix + suffix;</span><br><span class="line">    startBytePos = suffixesReader.getPosition();</span><br><span class="line">    suffixesReader.skipBytes(suffix);</span><br><span class="line">    ste.termExists = (code &amp; 1) == 0;</span><br><span class="line">    if (ste.termExists) &#123;</span><br><span class="line">      state.termBlockOrd++;</span><br><span class="line">      subCode = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      subCode = suffixLengthsReader.readVLong();</span><br><span class="line">      lastSubFP = fp - subCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int cmp =</span><br><span class="line">        Arrays.compareUnsigned(</span><br><span class="line">            suffixBytes,</span><br><span class="line">            startBytePos,</span><br><span class="line">            startBytePos + suffix,</span><br><span class="line">            target.bytes,</span><br><span class="line">            target.offset + prefix,</span><br><span class="line">            target.offset + target.length);</span><br><span class="line"></span><br><span class="line">    if (cmp &lt; 0) &#123;</span><br><span class="line">      // Current entry is still before the target;</span><br><span class="line">      // keep scanning</span><br><span class="line">    &#125; else if (cmp &gt; 0) &#123;</span><br><span class="line">      // Done!  Current entry is after target --</span><br><span class="line">      // return NOT_FOUND:</span><br><span class="line">      fillTerm();</span><br><span class="line"></span><br><span class="line">      // if (DEBUG) System.out.println(&quot;        maybe done exactOnly=&quot; + exactOnly + &quot;</span><br><span class="line">      // ste.termExists=&quot; + ste.termExists);</span><br><span class="line"></span><br><span class="line">      if (!exactOnly &amp;&amp; !ste.termExists) &#123;</span><br><span class="line">        // System.out.println(&quot;  now pushFrame&quot;);</span><br><span class="line">        // TODO this</span><br><span class="line">        // We are on a sub-block, and caller wants</span><br><span class="line">        // us to position to the next term after</span><br><span class="line">        // the target, so we must recurse into the</span><br><span class="line">        // sub-frame(s):</span><br><span class="line">        ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);</span><br><span class="line">        ste.currentFrame.loadBlock();</span><br><span class="line">        while (ste.currentFrame.next()) &#123;</span><br><span class="line">          ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length());</span><br><span class="line">          ste.currentFrame.loadBlock();         /////////////////////////////////////////////////// 这里会有流的加载</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // if (DEBUG) System.out.println(&quot;        not found&quot;);</span><br><span class="line">      return SeekStatus.NOT_FOUND;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Exact match!</span><br><span class="line"></span><br><span class="line">      // This cannot be a sub-block because we</span><br><span class="line">      // would have followed the index to this</span><br><span class="line">      // sub-block from the start:</span><br><span class="line"></span><br><span class="line">      assert ste.termExists;</span><br><span class="line">      fillTerm();</span><br><span class="line">      // if (DEBUG) System.out.println(&quot;        found!&quot;);</span><br><span class="line">      return SeekStatus.FOUND;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // It is possible (and OK) that terms index pointed us</span><br><span class="line">  // at this block, but, we scanned the entire block and</span><br><span class="line">  // did not find the term to position to.  This happens</span><br><span class="line">  // when the target is after the last term in the block</span><br><span class="line">  // (but, before the next term in the index).  EG</span><br><span class="line">  // target could be foozzz, and terms index pointed us</span><br><span class="line">  // to the foo* block, but the last term in this block</span><br><span class="line">  // was fooz (and, eg, first term in the next block will</span><br><span class="line">  // bee fop).</span><br><span class="line">  // if (DEBUG) System.out.println(&quot;      block end&quot;);</span><br><span class="line">  if (exactOnly) &#123;</span><br><span class="line">    fillTerm();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // TODO: not consistent that in the</span><br><span class="line">  // not-exact case we don&#x27;t next() into the next</span><br><span class="line">  // frame here</span><br><span class="line">  return SeekStatus.END;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>termState 是如何被反序列化的?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint hit: &quot;thread=main&quot;, org.apache.lucene.codecs.lucene90.Lucene90PostingsReader.decodeTerm(), line=194 bci=0</span><br><span class="line">194        final IntBlockTermState termState = (IntBlockTermState) _termState;</span><br><span class="line"></span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.Lucene90PostingsReader.decodeTerm (Lucene90PostingsReader.java:194)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnumFrame.decodeMetaData (SegmentTermsEnumFrame.java:476)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.termState (SegmentTermsEnum.java:1,178)</span><br><span class="line">  [4] org.apache.lucene.index.TermStates.build (TermStates.java:104)</span><br><span class="line">  [5] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">  public void decodeTerm(</span><br><span class="line">      DataInput in, FieldInfo fieldInfo, BlockTermState _termState, boolean absolute)</span><br><span class="line">      throws IOException &#123;</span><br><span class="line">    final IntBlockTermState termState = (IntBlockTermState) _termState;</span><br><span class="line">    final boolean fieldHasPositions =</span><br><span class="line">        fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) &gt;= 0;</span><br><span class="line">    final boolean fieldHasOffsets =</span><br><span class="line">        fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)</span><br><span class="line">            &gt;= 0;</span><br><span class="line">    final boolean fieldHasPayloads = fieldInfo.hasPayloads();</span><br><span class="line"></span><br><span class="line">    if (absolute) &#123;</span><br><span class="line">      termState.docStartFP = 0;</span><br><span class="line">      termState.posStartFP = 0;</span><br><span class="line">      termState.payStartFP = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final long l = in.readVLong();</span><br><span class="line">    if ((l &amp; 0x01) == 0) &#123;</span><br><span class="line">      termState.docStartFP += l &gt;&gt;&gt; 1;</span><br><span class="line">      if (termState.docFreq == 1) &#123;</span><br><span class="line">        termState.singletonDocID = in.readVInt();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        termState.singletonDocID = -1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      assert absolute == false;</span><br><span class="line">      assert termState.singletonDocID != -1;</span><br><span class="line">      termState.singletonDocID += BitUtil.zigZagDecode(l &gt;&gt;&gt; 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fieldHasPositions) &#123;</span><br><span class="line">      termState.posStartFP += in.readVLong();</span><br><span class="line">      if (fieldHasOffsets || fieldHasPayloads) &#123;</span><br><span class="line">        termState.payStartFP += in.readVLong();</span><br><span class="line">      &#125;</span><br><span class="line">      if (termState.totalTermFreq &gt; BLOCK_SIZE) &#123;</span><br><span class="line">        termState.lastPosBlockOffset = in.readVLong();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        termState.lastPosBlockOffset = -1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (termState.docFreq &gt; BLOCK_SIZE) &#123;</span><br><span class="line">      termState.skipOffset = in.readVLong();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      termState.skipOffset = -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其实ste持有term的引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main[2] dump ste.term.ref.bytes</span><br><span class="line"> ste.term.ref.bytes = &#123;</span><br><span class="line">97, 109, 0, 0, 0, 0, 0, 0</span><br><span class="line">&#125;</span><br><span class="line">main[2] where</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnumFrame.decodeMetaData (SegmentTermsEnumFrame.java:476)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.termState (SegmentTermsEnum.java:1,178)</span><br><span class="line">  [4] org.apache.lucene.index.TermStates.build (TermStates.java:104)</span><br><span class="line">  [5] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [10] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>

<p>ste.in 描述的是读取的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> ste.in = &#123;</span><br><span class="line">    $assertionsDisabled: true</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.EMPTY_FLOATBUFFER: instance of java.nio.HeapFloatBuffer(id=1473)</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.EMPTY_LONGBUFFER: instance of java.nio.HeapLongBuffer(id=1474)</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.EMPTY_INTBUFFER: instance of java.nio.HeapIntBuffer(id=1475)</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.length: 1993</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.chunkSizeMask: 1073741823</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.chunkSizePower: 30</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.guard: instance of org.apache.lucene.store.ByteBufferGuard(id=1476)</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.buffers: instance of java.nio.ByteBuffer[1] (id=1477)</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.curBufIndex: 0</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.curBuf: instance of java.nio.DirectByteBufferR(id=1479)</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.curLongBufferViews: null</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.curIntBufferViews: null</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.curFloatBufferViews: null</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.isClone: true</span><br><span class="line">    org.apache.lucene.store.ByteBufferIndexInput.$assertionsDisabled: true</span><br><span class="line">    org.apache.lucene.store.IndexInput.resourceDescription: &quot;MMapIndexInput(path=&quot;/home/dai/index/_7.cfs&quot;) [slice=_7_Lucene90_0.tim]&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.amazingkoala.com.cn/Lucene/Search/2020/0812/161.html">相关阅读</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public void nextLeaf() &#123;</span><br><span class="line">  // if (DEBUG) System.out.println(&quot;  frame.next ord=&quot; + ord + &quot; nextEnt=&quot; + nextEnt + &quot;</span><br><span class="line">  // entCount=&quot; + entCount);</span><br><span class="line">  assert nextEnt != -1 &amp;&amp; nextEnt &lt; entCount</span><br><span class="line">      : &quot;nextEnt=&quot; + nextEnt + &quot; entCount=&quot; + entCount + &quot; fp=&quot; + fp;</span><br><span class="line">  nextEnt++;</span><br><span class="line">  suffix = suffixLengthsReader.readVInt();</span><br><span class="line">  startBytePos = suffixesReader.getPosition();</span><br><span class="line">  ste.term.setLength(prefix + suffix);</span><br><span class="line">  ste.term.grow(ste.term.length());</span><br><span class="line">  suffixesReader.readBytes(ste.term.bytes(), prefix, suffix);</span><br><span class="line">  ste.termExists = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean nextNonLeaf() throws IOException &#123;</span><br><span class="line">  // if (DEBUG) System.out.println(&quot;  stef.next ord=&quot; + ord + &quot; nextEnt=&quot; + nextEnt + &quot; entCount=&quot;</span><br><span class="line">  // + entCount + &quot; fp=&quot; + suffixesReader.getPosition());</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (nextEnt == entCount) &#123;</span><br><span class="line">      assert arc == null || (isFloor &amp;&amp; isLastInFloor == false)</span><br><span class="line">          : &quot;isFloor=&quot; + isFloor + &quot; isLastInFloor=&quot; + isLastInFloor;</span><br><span class="line">      loadNextFloorBlock();</span><br><span class="line">      if (isLeafBlock) &#123;</span><br><span class="line">        nextLeaf();</span><br><span class="line">        return false;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert nextEnt != -1 &amp;&amp; nextEnt &lt; entCount</span><br><span class="line">        : &quot;nextEnt=&quot; + nextEnt + &quot; entCount=&quot; + entCount + &quot; fp=&quot; + fp;</span><br><span class="line">    nextEnt++;</span><br><span class="line">    final int code = suffixLengthsReader.readVInt();</span><br><span class="line">    suffix = code &gt;&gt;&gt; 1;</span><br><span class="line">    startBytePos = suffixesReader.getPosition();</span><br><span class="line">    ste.term.setLength(prefix + suffix);</span><br><span class="line">    ste.term.grow(ste.term.length());</span><br><span class="line">    suffixesReader.readBytes(ste.term.bytes(), prefix, suffix);   // 这里是最核心的地方吗?</span><br><span class="line">    if ((code &amp; 1) == 0) &#123;</span><br><span class="line">      // A normal term</span><br><span class="line">      ste.termExists = true;</span><br><span class="line">      subCode = 0;</span><br><span class="line">      state.termBlockOrd++;</span><br><span class="line">      return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // A sub-block; make sub-FP absolute:</span><br><span class="line">      ste.termExists = false;</span><br><span class="line">      subCode = suffixLengthsReader.readVLong();</span><br><span class="line">      lastSubFP = fp - subCode;</span><br><span class="line">      // if (DEBUG) &#123;</span><br><span class="line">      // System.out.println(&quot;    lastSubFP=&quot; + lastSubFP);</span><br><span class="line">      // &#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>看上去这就行读取term 在文件中的位置信息:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnumFrame.scanToTermLeaf (SegmentTermsEnumFrame.java:593)</span><br><span class="line">  [2] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnumFrame.scanToTerm (SegmentTermsEnumFrame.java:530)</span><br><span class="line">  [3] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.seekExact (SegmentTermsEnum.java:538)</span><br><span class="line">  [4] org.apache.lucene.index.TermStates.loadTermsEnum (TermStates.java:117)</span><br><span class="line">  [5] org.apache.lucene.index.TermStates.build (TermStates.java:102)</span><br><span class="line">  [6] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [8] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [9] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [10] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [11] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [12] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br><span class="line">main[1] dump suffixBytes</span><br><span class="line"> suffixBytes = &#123;</span><br><span class="line">97, 109, 97, 110, 100, 98, 117, 116, 99, 97, 110, 100, 111, 104, 101, 108, 108, 111, 104, 105, 105, 105, 115, 105, 116, 107, 110, 111, 119, 109, 97, 121, 109, 111, 110, 103, 111, 110, 111, 116, 116, 114, 121, 119, 104, 97, 116, 119, 111, 114, 108, 100, 121, 111, 117, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="term-对应docfreq-的统计信息的读取位置"><a href="#term-对应docfreq-的统计信息的读取位置" class="headerlink" title="term 对应docfreq 的统计信息的读取位置"></a>term 对应docfreq 的统计信息的读取位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">main[1] list</span><br><span class="line">451          // postings</span><br><span class="line">452    </span><br><span class="line">453          // TODO: if docFreq were bulk decoded we could</span><br><span class="line">454          // just skipN here:</span><br><span class="line">455 =&gt;       if (statsSingletonRunLength &gt; 0) &#123;</span><br><span class="line">456            state.docFreq = 1;</span><br><span class="line">457            state.totalTermFreq = 1;</span><br><span class="line">458            statsSingletonRunLength--;</span><br><span class="line">459          &#125; else &#123;</span><br><span class="line">460            int token = statsReader.readVInt();</span><br><span class="line">main[1] print statsSingletonRunLength</span><br><span class="line"> statsSingletonRunLength = 0</span><br><span class="line">main[1] next</span><br><span class="line">&gt; </span><br><span class="line">Step completed: &quot;thread=main&quot;, org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnumFrame.decodeMetaData(), line=460 bci=80</span><br><span class="line">460            int token = statsReader.readVInt();</span><br><span class="line"></span><br><span class="line">main[1] list</span><br><span class="line">456            state.docFreq = 1;</span><br><span class="line">457            state.totalTermFreq = 1;</span><br><span class="line">458            statsSingletonRunLength--;</span><br><span class="line">459          &#125; else &#123;</span><br><span class="line">460 =&gt;         int token = statsReader.readVInt();</span><br><span class="line">461            if ((token &amp; 1) == 1) &#123;</span><br><span class="line">462              state.docFreq = 1;</span><br><span class="line">463              state.totalTermFreq = 1;</span><br><span class="line">464              statsSingletonRunLength = token &gt;&gt;&gt; 1;</span><br><span class="line">465            &#125; else &#123;</span><br><span class="line">main[1] print statsReader</span><br><span class="line"> statsReader = &quot;org.apache.lucene.store.ByteArrayDataInput@6b67034&quot;</span><br><span class="line">main[1] dump statsReader</span><br><span class="line"> statsReader = &#123;</span><br><span class="line">    bytes: instance of byte[64] (id=1520)</span><br><span class="line">    pos: 0</span><br><span class="line">    limit: 16</span><br><span class="line">&#125;</span><br><span class="line">main[1] dump statsReader.bytes</span><br><span class="line"> statsReader.bytes = &#123;</span><br><span class="line">4, 0, 9, 2, 1, 4, 0, 3, 2, 1, 1, 2, 1, 7, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>搜索的<code>term</code> 是<code>am</code>对应的是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">00000000  3f d7 6c 17 12 42 6c 6f  63 6b 54 72 65 65 54 65  |?.l..BlockTreeTe|</span><br><span class="line">00000010  72 6d 73 44 69 63 74 00  00 00 00 fe ea 80 e6 45  |rmsDict........E|</span><br><span class="line">00000020  20 d8 56 64 1b 1b 1b 89  70 fe 67 0a 4c 75 63 65  | .Vd....p.g.Luce|</span><br><span class="line">00000030  6e 65 39 30 5f 30 25 bc  03 61 6d 61 6e 64 62 75  |ne90_0%..amandbu|</span><br><span class="line">00000040  74 63 61 6e 64 6f 68 65  6c 6c 6f 68 69 69 69 73  |tcandohellohiiis|</span><br><span class="line">00000050  69 74 6b 6e 6f 77 6d 61  79 6d 6f 6e 67 6f 6e 6f  |itknowmaymongono|</span><br><span class="line">00000060  74 74 72 79 77 68 61 74  77 6f 72 6c 64 79 6f 75  |ttrywhatworldyou|</span><br><span class="line">00000070  24 02 03 03 03 02 05 02  01 02 02 04 03 05 03 03  |$...............|</span><br><span class="line">00000080  04 05 03 10 04 00 09 02  01 04 00 03 02 01 01 02  |................|   &lt;----  在这一行第四个开始的序列</span><br><span class="line">00000090  01 07 02 02 26 7a 3d 04  01 02 03 01 01 01 01 01  |....&amp;z=.........|</span><br><span class="line">000000a0  05 01 01 01 00 02 04 00  02 01 01 01 01 01 02 01  |................|</span><br><span class="line">000000b0  01 01 02 01 01 01 01 05  01 03 01 05 a4 03 2f 68  |............../h|</span><br><span class="line">000000c0  6f 6d 65 2f 75 62 75 6e  74 75 2f 64 6f 63 2f 68  |ome/ubuntu/doc/h|</span><br><span class="line">000000d0  65 6c 6c 6f 2e 74 78 74  2f 68 6f 6d 65 2f 75 62  |ello.txt/home/ub|</span><br><span class="line">000000e0  75 6e 74 75 2f 64 6f 63  2f 6d 6f 6e 67 6f 2e 74  |untu/doc/mongo.t|</span><br><span class="line">000000f0  78 74 05 1a 01 03 04 82  01 01 03 c0 28 93 e8 00  |xt..........(...|</span><br><span class="line">00000100  00 00 00 00 00 00 00 da  02 a3 a3                 |...........|</span><br></pre></td></tr></table></figure>


<p>那么docFreq 的赋值在哪里呢? </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> currentFrame.state.docFreq = 2</span><br><span class="line">main[1] list</span><br><span class="line">1,113        assert !eof;</span><br><span class="line">1,114        // if (DEBUG) System.out.println(&quot;BTR.docFreq&quot;);</span><br><span class="line">1,115        currentFrame.decodeMetaData();</span><br><span class="line">1,116        // if (DEBUG) System.out.println(&quot;  return &quot; + currentFrame.state.docFreq);</span><br><span class="line">1,117 =&gt;     return currentFrame.state.docFreq;</span><br><span class="line">1,118      &#125;</span><br><span class="line">1,119    </span><br><span class="line">1,120      @Override</span><br><span class="line">1,121      public long totalTermFreq() throws IOException &#123;</span><br><span class="line">1,122        assert !eof;</span><br><span class="line">main[1] where</span><br><span class="line">  [1] org.apache.lucene.codecs.lucene90.blocktree.SegmentTermsEnum.docFreq (SegmentTermsEnum.java:1,117)</span><br><span class="line">  [2] org.apache.lucene.index.TermStates.build (TermStates.java:107)</span><br><span class="line">  [3] org.apache.lucene.search.TermQuery.createWeight (TermQuery.java:227)</span><br><span class="line">  [4] org.apache.lucene.search.IndexSearcher.createWeight (IndexSearcher.java:885)</span><br><span class="line">  [5] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:686)</span><br><span class="line">  [6] org.apache.lucene.search.IndexSearcher.searchAfter (IndexSearcher.java:532)</span><br><span class="line">  [7] org.apache.lucene.search.IndexSearcher.search (IndexSearcher.java:542)</span><br><span class="line">  [8] org.apache.lucene.demo.SearchFiles.doPagingSearch (SearchFiles.java:180)</span><br><span class="line">  [9] org.apache.lucene.demo.SearchFiles.main (SearchFiles.java:150)</span><br></pre></td></tr></table></figure>

<p>读取的过程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">readByte:110, ByteBufferIndexInput (org.apache.lucene.store)</span><br><span class="line">readVInt:121, DataInput (org.apache.lucene.store)</span><br><span class="line">readVIntBlock:149, Lucene90PostingsReader (org.apache.lucene.codecs.lucene90)</span><br><span class="line">refillDocs:472, Lucene90PostingsReader$BlockDocsEnum (org.apache.lucene.codecs.lucene90)</span><br><span class="line">advance:538, Lucene90PostingsReader$BlockDocsEnum (org.apache.lucene.codecs.lucene90)</span><br><span class="line">advance:77, SlowImpactsEnum (org.apache.lucene.index)</span><br><span class="line">advance:128, ImpactsDISI (org.apache.lucene.search)</span><br><span class="line">nextDoc:133, ImpactsDISI (org.apache.lucene.search)</span><br><span class="line">scoreAll:301, Weight$DefaultBulkScorer (org.apache.lucene.search)</span><br><span class="line">score:247, Weight$DefaultBulkScorer (org.apache.lucene.search)</span><br><span class="line">score:38, BulkScorer (org.apache.lucene.search)</span><br><span class="line">search:776, IndexSearcher (org.apache.lucene.search)</span><br><span class="line">search:694, IndexSearcher (org.apache.lucene.search)</span><br><span class="line">search:688, IndexSearcher (org.apache.lucene.search)</span><br><span class="line">searchAfter:523, IndexSearcher (org.apache.lucene.search)</span><br><span class="line">search:538, IndexSearcher (org.apache.lucene.search)</span><br><span class="line">doPagingSearch:161, SearchFiles (com.dinosaur.lucene.skiptest)</span><br><span class="line">queryTest:52, QueryTest (com.dinosaur.lucene.demo)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="tim-文件在哪里初始化"><a href="#tim-文件在哪里初始化" class="headerlink" title="tim 文件在哪里初始化"></a>tim 文件在哪里初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">void loadBlock() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">  // Clone the IndexInput lazily, so that consumers</span><br><span class="line">  // that just pull a TermsEnum to</span><br><span class="line">  // seekExact(TermState) don&#x27;t pay this cost:</span><br><span class="line">  ste.initIndexInput();</span><br><span class="line"></span><br><span class="line">  if (nextEnt != -1) &#123;</span><br><span class="line">    // Already loaded</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // System.out.println(&quot;blc=&quot; + blockLoadCount);</span><br><span class="line"></span><br><span class="line">  ste.in.seek(fp);</span><br><span class="line">  int code = ste.in.readVInt();</span><br><span class="line">  entCount = code &gt;&gt;&gt; 1;</span><br><span class="line">  assert entCount &gt; 0;</span><br><span class="line">  isLastInFloor = (code &amp; 1) != 0;</span><br><span class="line"></span><br><span class="line">  assert arc == null || (isLastInFloor || isFloor)</span><br><span class="line">      : &quot;fp=&quot; + fp + &quot; arc=&quot; + arc + &quot; isFloor=&quot; + isFloor + &quot; isLastInFloor=&quot; + isLastInFloor;</span><br><span class="line"></span><br><span class="line">  // TODO: if suffixes were stored in random-access</span><br><span class="line">  // array structure, then we could do binary search</span><br><span class="line">  // instead of linear scan to find target term; eg</span><br><span class="line">  // we could have simple array of offsets</span><br><span class="line"></span><br><span class="line">  final long startSuffixFP = ste.in.getFilePointer();</span><br><span class="line">  // term suffixes:</span><br><span class="line">  final long codeL = ste.in.readVLong();</span><br><span class="line">  isLeafBlock = (codeL &amp; 0x04) != 0;</span><br><span class="line">  final int numSuffixBytes = (int) (codeL &gt;&gt;&gt; 3);</span><br><span class="line">  if (suffixBytes.length &lt; numSuffixBytes) &#123;</span><br><span class="line">    suffixBytes = new byte[ArrayUtil.oversize(numSuffixBytes, 1)];</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    compressionAlg = CompressionAlgorithm.byCode((int) codeL &amp; 0x03);</span><br><span class="line">  &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">    throw new CorruptIndexException(e.getMessage(), ste.in, e);</span><br><span class="line">  &#125;</span><br><span class="line">  compressionAlg.read(ste.in, suffixBytes, numSuffixBytes);</span><br><span class="line">  suffixesReader.reset(suffixBytes, 0, numSuffixBytes);</span><br><span class="line"></span><br><span class="line">  int numSuffixLengthBytes = ste.in.readVInt();</span><br><span class="line">  final boolean allEqual = (numSuffixLengthBytes &amp; 0x01) != 0;</span><br><span class="line">  numSuffixLengthBytes &gt;&gt;&gt;= 1;</span><br><span class="line">  if (suffixLengthBytes.length &lt; numSuffixLengthBytes) &#123;</span><br><span class="line">    suffixLengthBytes = new byte[ArrayUtil.oversize(numSuffixLengthBytes, 1)];</span><br><span class="line">  &#125;</span><br><span class="line">  if (allEqual) &#123;</span><br><span class="line">    Arrays.fill(suffixLengthBytes, 0, numSuffixLengthBytes, ste.in.readByte());</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ste.in.readBytes(suffixLengthBytes, 0, numSuffixLengthBytes);</span><br><span class="line">  &#125;</span><br><span class="line">  suffixLengthsReader.reset(suffixLengthBytes, 0, numSuffixLengthBytes);</span><br><span class="line">  totalSuffixBytes = ste.in.getFilePointer() - startSuffixFP;</span><br><span class="line"></span><br><span class="line">  /*if (DEBUG) &#123;</span><br><span class="line">  if (arc == null) &#123;</span><br><span class="line">  System.out.println(&quot;    loadBlock (next) fp=&quot; + fp + &quot; entCount=&quot; + entCount + &quot; prefixLen=&quot; + prefix + &quot; isLastInFloor=&quot; + isLastInFloor + &quot; leaf?=&quot; + isLeafBlock);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  System.out.println(&quot;    loadBlock (seek) fp=&quot; + fp + &quot; entCount=&quot; + entCount + &quot; prefixLen=&quot; + prefix + &quot; hasTerms?=&quot; + hasTerms + &quot; isFloor?=&quot; + isFloor + &quot; isLastInFloor=&quot; + isLastInFloor + &quot; leaf?=&quot; + isLeafBlock);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;*/</span><br><span class="line"></span><br><span class="line">  // stats</span><br><span class="line">  int numBytes = ste.in.readVInt();</span><br><span class="line">  if (statBytes.length &lt; numBytes) &#123;</span><br><span class="line">    statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];</span><br><span class="line">  &#125;</span><br><span class="line">  ste.in.readBytes(statBytes, 0, numBytes);</span><br><span class="line">  statsReader.reset(statBytes, 0, numBytes);</span><br><span class="line">  statsSingletonRunLength = 0;</span><br><span class="line">  metaDataUpto = 0;</span><br><span class="line"></span><br><span class="line">  state.termBlockOrd = 0;</span><br><span class="line">  nextEnt = 0;</span><br><span class="line">  lastSubFP = -1;</span><br><span class="line"></span><br><span class="line">  // TODO: we could skip this if !hasTerms; but</span><br><span class="line">  // that&#x27;s rare so won&#x27;t help much</span><br><span class="line">  // metadata</span><br><span class="line">  numBytes = ste.in.readVInt();</span><br><span class="line">  if (bytes.length &lt; numBytes) &#123;</span><br><span class="line">    bytes = new byte[ArrayUtil.oversize(numBytes, 1)];</span><br><span class="line">  &#125;</span><br><span class="line">  ste.in.readBytes(bytes, 0, numBytes);</span><br><span class="line">  bytesReader.reset(bytes, 0, numBytes);</span><br><span class="line"></span><br><span class="line">  // Sub-blocks of a single floor block are always</span><br><span class="line">  // written one after another -- tail recurse:</span><br><span class="line">  fpEnd = ste.in.getFilePointer();</span><br><span class="line">  // if (DEBUG) &#123;</span><br><span class="line">  //   System.out.println(&quot;      fpEnd=&quot; + fpEnd);</span><br><span class="line">  // &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我们知道Lucene将索引文件拆分为了多个文件，这里我们仅讨论倒排索引部分。</span><br><span class="line"></span><br><span class="line">Lucene把用于存储Term的索引文件叫Terms Index，它的后缀是.tip；把Postings信息分别存储在.doc、.pay、.pox，分别记录Postings的DocId信息和Term的词频、Payload信息、pox是记录位置信息。Terms Dictionary的文件后缀称为.tim，它是Term与Postings的关系纽带，存储了Term和其对应的Postings文件指针。</span><br><span class="line"></span><br><span class="line">总体来说，通过Terms Index(.tip)能够快速地在Terms Dictionary(.tim)中找到你的想要的Term，以及它对应的Postings文件指针与Term在Segment作用域上的统计信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">postings: 实际上Postings包含的东西并不仅仅是DocIDs（我们通常把这一个有序文档编号系列叫DocIDs），它还包括文档编号、以及词频、Term在文档中的位置信息、还有Payload数据。</span><br><span class="line"></span><br><span class="line">所以关于倒排索引至少涉及5类文件，本文不会全面展开。</span><br></pre></td></tr></table></figure>




<p>相关阅读</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://lucene.apache.org/core/3_0_3/fileformats.html">https://lucene.apache.org/core/3_0_3/fileformats.html</a></li>
<li><a target="_blank" rel="noopener" href="https://lucene.apache.org/core/2_9_4/scoring.html">https://lucene.apache.org/core/2_9_4/scoring.html</a></li>
<li><a target="_blank" rel="noopener" href="https://codeantenna.com/a/bGcgCLjKCk">https://codeantenna.com/a/bGcgCLjKCk</a></li>
<li><a target="_blank" rel="noopener" href="https://www.dounaite.com/article/628d0f2bf8519f4c0cd30f45.html">https://www.dounaite.com/article/628d0f2bf8519f4c0cd30f45.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/forfuture1978/p/3940965.html">tim tip</a></li>
<li><a target="_blank" rel="noopener" href="http://cmph.sourceforge.net/papers/chm92.pdf">An optimal algorithm for generating minimal perfect hash functions., Information Processing Letters</a></li>
<li><a target="_blank" rel="noopener" href="https://www.amazingkoala.com.cn/Lucene/Search/2020/0714/154.html">tim 文件,fst</a></li>
<li><a target="_blank" rel="noopener" href="https://www.amazingkoala.com.cn/Lucene/yasuocunchu/2019/0220/35.html">fst</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7067211930494042148">fst</a></li>
<li><a target="_blank" rel="noopener" href="https://www.shenyanchao.cn/blog/2018/12/04/lucene-fst/">fst</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wang_hnust/article/details/87988587">lucene arc fst</a></li>
<li><a target="_blank" rel="noopener" href="https://www.freesion.com/article/6984398617/">tim 读取和字段</a></li>
<li><a target="_blank" rel="noopener" href="https://www.merl.com/publications/docs/TR96-13.pdf">fst paper</a></li>
<li><a target="_blank" rel="noopener" href="https://cs.union.edu/~striegnk/courses/nlp-with-prolog/html/node13.html">相关阅读</a></li>
<li><a target="_blank" rel="noopener" href="https://www.6aiq.com/article/1586704007975">collect</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/studyhs/p/9088056.html">collect and reduce</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/alex_xfboy/article/details/90174840">mmap</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/384486147">fdt docment</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/sbp810050504/1533162">fdt 压缩和解压</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wang_hnust/article/details/88361568">fst term 读取和搜索</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sgyuanshi/article/details/105498418">搜索</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/studyhs/p/9092928.html">排序获取docid</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/studyhs/p/9088056.html">倒排索引pq定位</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI4Njk3NjU1OQ==&mid=2247484121&idx=1&sn=4450469c5ebd001c75214b58534e2c4e&chksm=ebd5fd99dca2748f41a8b3ff8867e31cf5124110a6649d7e3cc96a0395e238936b97f0b05b0f&scene=21#wechat_redirect">Impact 和topdoc定位docid</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/LGxYZ6plHAWVz7Mw6MAEtw">Impact 和topdoc定位docid</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/184983670">遍历doc</a></li>
<li><a target="_blank" rel="noopener" href="https://marian5211.github.io/2017/11/22/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8ETop-k%E5%BF%AB%E9%80%9F%E6%A3%80%E7%B4%A2%E9%97%AE%E9%A2%98/">topk</a></li>
<li><a target="_blank" rel="noopener" href="https://www.google.com/search?q=startFp+lucene&oq=startFp++lucene&aqs=chrome..69i57j33i160l4.6287j0j4&sourceid=chrome&ie=UTF-8">term相关索引</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b05eed0da6ad">tim 文件格式</a></li>
<li><a target="_blank" rel="noopener" href="http://examples.mikemccandless.com/fst.py?terms=&cmd=Build+it!">fst 例子</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/morfologik/morfologik-stemming">fst 工具github</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/news/380648">Burst Tries  BlockTree</a></li>
<li><a target="_blank" rel="noopener" href="https://www.amazingkoala.com.cn/Lucene/Index/2020/0528/144.html">TermId 和TermsDict</a></li>
<li><a target="_blank" rel="noopener" href="https://www.6aiq.com/article/1564413040138">lucene 文件结构</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/lucene/" rel="tag"># lucene</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/18/llvm/" rel="prev" title="llvm">
      <i class="fa fa-chevron-left"></i> llvm
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/04/rabbitmq%E5%BF%83%E8%B7%B3%E9%97%AE%E9%A2%98%E5%92%8Cphp/" rel="next" title="rabbitmq心跳问题和php">
      rabbitmq心跳问题和php <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vint"><span class="nav-number">1.</span> <span class="nav-text">Vint</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="nav-number">2.</span> <span class="nav-text">相关代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%A7%8Bdebug"><span class="nav-number">2.1.</span> <span class="nav-text">开始debug</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8Bfdt%E6%96%87%E4%BB%B6"><span class="nav-number">3.</span> <span class="nav-text">查看fdt文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#writeField"><span class="nav-number">4.</span> <span class="nav-text">writeField</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E8%AF%8D%E5%92%8C%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="nav-number">5.</span> <span class="nav-text">分词和倒排索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#term%E6%8F%8F%E8%BF%B0"><span class="nav-number">5.1.</span> <span class="nav-text">term描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#term-%E5%86%99%E5%85%A5tim%E6%96%87%E4%BB%B6"><span class="nav-number">5.2.</span> <span class="nav-text">term 写入tim文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2"><span class="nav-number">6.</span> <span class="nav-text">查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96term"><span class="nav-number">6.1.</span> <span class="nav-text">获取term</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87arc-%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94output"><span class="nav-number">6.2.</span> <span class="nav-text">通过arc 获取对应output</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%BC%80tim%E6%96%87%E4%BB%B6"><span class="nav-number">6.3.</span> <span class="nav-text">打开tim文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#docid-%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%87%E6%A1%88%E5%86%85%E5%AE%B9"><span class="nav-number">7.</span> <span class="nav-text">docid 获取对应的文案内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87docid-%E8%8E%B7%E5%8F%96document"><span class="nav-number">7.1.</span> <span class="nav-text">通过docid 获取document</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE"><span class="nav-number">7.2.</span> <span class="nav-text">通过堆外内存加载文件数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filechannel-%E7%9A%84-map"><span class="nav-number">7.3.</span> <span class="nav-text">filechannel 的 map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%A1%AC%E7%9B%98%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">7.3.1.</span> <span class="nav-text">mmap 映射文件读取硬盘中的内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96mmap%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">7.3.2.</span> <span class="nav-text">读取mmap后的数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="nav-number">8.</span> <span class="nav-text">文件格式介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fnm-%E6%96%87%E4%BB%B6"><span class="nav-number">8.1.</span> <span class="nav-text">.fnm 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fdt"><span class="nav-number">8.2.</span> <span class="nav-text">.fdt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BDdoc%E7%9A%84%E5%86%85%E5%AE%B9%E5%88%B0Document-%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.3.</span> <span class="nav-text">加载doc的内容到Document 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87docid-%E6%9E%84%E5%BB%BA-SerializedDocument"><span class="nav-number">8.4.</span> <span class="nav-text">通过docid 构建 SerializedDocument</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#term-%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%A4%84%E7%90%86"><span class="nav-number">8.5.</span> <span class="nav-text">term 文件的加载和处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">8.6.</span> <span class="nav-text">获取所有的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#topk-collector%E7%9A%84%E5%A0%86%E6%A0%88"><span class="nav-number">8.7.</span> <span class="nav-text">topk collector的堆栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search-%E8%BF%87%E7%A8%8B"><span class="nav-number">8.8.</span> <span class="nav-text">search 过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96hits-%E6%95%B0%E9%87%8F%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">8.9.</span> <span class="nav-text">获取hits 数量的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#term-%E5%AF%B9%E5%BA%94docfreq-%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%E7%9A%84%E8%AF%BB%E5%8F%96%E4%BD%8D%E7%BD%AE"><span class="nav-number">8.10.</span> <span class="nav-text">term 对应docfreq 的统计信息的读取位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tim-%E6%96%87%E4%BB%B6%E5%9C%A8%E5%93%AA%E9%87%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.11.</span> <span class="nav-text">tim 文件在哪里初始化</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">dinosaur</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">256</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">73</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/769344359" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;769344359" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/thedinosaurmail@gmail.com" title="E-Mail → thedinosaurmail@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dinosaur</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

</body>
</html>
